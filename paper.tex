\documentclass[11pt]{article}

\usepackage{notation/modes}
\usepackage{notation/judgments}
\usepackage{notation/abts}
\usepackage{notation/common}

\usepackage{appendix}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{agda} % this should come after ams*
\usepackage{catchfilebetweentags}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifdraft}
\usepackage{ifthen}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{scalerel}
\usepackage{setspace}
\usepackage{stmaryrd}
\usepackage{supertabular}
\usepackage{tikz-cd}
\usepackage{tikzpfeile}
\usepackage{todonotes}
\usepackage{url}

\definecolor{dark-gray}{gray}{0.20}

% fonts
\usepackage{pxfonts}
\usepackage{eulervm}
\usepackage{bbold}
\usepackage[
  activate={true,nocompatibility},
  kerning=true,
  spacing=true,
  tracking=true
]{microtype}
\microtypecontext{spacing=nonfrench}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}
%% Euler doesn't have \varsigma
\DeclareSymbolFont{greekletters}{OML}{cmr}{m}{it}
\DeclareMathSymbol{\varsigma}{\mathalpha}{greekletters}{"26}

\newcommand\HypCat{\mathbf{H}}
\newcommand\Supp[1]{\mathbf{supp}(#1)}
\newcommand\SupportsUnmoded[3]{#1 \blacktriangleright_{#2} #3}
\newcommand\Supports[3]{\SupportsUnmoded{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}}

\newcommand\CalcFV[2]{
  \FV{\IMode{#1}}\leadsto \OMode{#2}
}

\newcommand\CalcFS[2]{
  \FS{\IMode{#1}}\leadsto \OMode{#2}
}

\newcommand\SortExp{\mathtt{exp}}

\newcommand\IsWf[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}\in_{\mathbf{wf}}\IMode{#5}%
}

\newcommand\Sheaves[1]{\mathbf{Sh}\left(#1\right)}
\newcommand\Presheaves[1]{\mathbf{Psh}\left(#1\right)}
\newcommand\Sheafify[1]{#1^{\#}}
\newcommand\ConstPsh[1]{\Delta[#1]}
\newcommand\ConstSh[1]{\Delta^\#[#1]}
\newcommand\SCtxSite{\SymSets[\Sorts]}

\DeclareMathOperator{\Perm}{\mathbf{Perm}}


\begin{document}

\title{Syntax and Semantics of Abstract Binding Trees}
\date{}
\author{Jon Sterling and Darin Morrison}
\maketitle

Abstract binding trees (abts) are a generalization of abstract syntax trees
where operators may express variable binding structure as part of their arities.
Originally formulated by Peter Aczel~\cite{aczel:1978}, unisorted abts have been
deployed successfully as the uniform syntactic framework for several
implementations of Constructive Type Theory, including
Nuprl~\cite{constable:1986}, MetaPRL~\cite{hickey:2003} and
JonPRL~\cite{jonprl:2015}.

In \emph{Practical Foundations for Programming Languages}~\cite{harper:2016},
Robert Harper develops the multi-sorted version of abstract binding trees and
proposes an extension to include families of operators indexed by
\emph{symbols}, which are, unlike variables, subject to only
distinctness-preserving renaming and not substitution; furthermore, symbols do
not appear in the syntax of abts, and are only introduced as parameters to
operators. This extension to support symbols is essential for a correct
treatment of programming languages with open sums (e.g. ML's \texttt{exn} type),
as well as assignable references.

In parallel, M.\ Fiore and his collaborators have developed the categorical
semantics for several variations of second-order algebraic
theories~\cite{fiore:1999, fiore:2005, fiore-hur:2010, fiore-mamoud:2010}; of
these, the simply sorted variants are equivalent to Harper's abstract binding
trees augmented with a notion of second-order variable (metavariable).

The contribution of this paper is the development of the syntax and semantics
of multi-sorted nominal abts, an extension of second order universal algebra to
support symbol-indexed families of operators. Additionally, we have developed
the categorical semantics for abts formally in Constructive Type Theory using
the Agda proof assistant~\cite{norell:2007}; we have also developed an
implementation for abstract binding trees in Standard ML, which we intend to
integrate into the JonPRL proof assistant \cite{jonprl:2015}.

\section{Categorical Preliminaries}

Fix a set $\Sorts$ of \emph{sorts}; we will say $\IsSort{\tau}$ when
$\Member{\tau}{\Sorts}$. In this section, we will develop a theory of sets
varying over collections of $\Sorts$-sorted symbols.

Let $\SymSets$ be the category of finite cardinals and their injective maps;
then the comma construction $\SCtx$, is the category of contexts of symbols
whose objects are finite sets of symbols $U$ and sort-assignments
\begin{tikzcd}[cramped]
  \IMode{U}\arrow[r, "\IMode{\mathfrak{s}}"] &\IMode{\Sorts}
\end{tikzcd}, and whose morphisms are
sort-preserving renamings; we will write $\Upsilon$ for a symbol context
$(U,\mathfrak{s})$.

\begin{remark}

  To be precise, $\SCtx$ is an abuse of notation for the comma category
  $\Dom{-}_\SymSets\downarrow \Delta[\Sorts]$, with $\Dom{-}_\SymSets$ the
  forgetful functor from $\SymSets$ to $\Sets$, and
  $\Define{\Delta[\Sorts](*)}{\Sorts}$ a constant functor from $\mathbb{1}$ to $\Sets$.
  Formally, an object of $\SCtx$ is, then, a triple $\Tuple{U, *,
  \mathfrak{s}}$ with $U$ an object in $\SymSets$, $*$ the unique object in
  $\mathbb{1}$, and $\mathfrak{s}$ a function $\Dom{U}_\SymSets\ra
  \Sorts$; an arrow $\Of{\varrho}{\Tuple{U,*,\mathfrak{s}}\ra
  \Tuple{V,*,\mathfrak{t}}}$ is a commuting triangle like the following:
  \[
    \begin{tikzcd}[cramped]
      \IMode{\Dom{U}_\SymSets}
        \arrow[rr, "\IMode{\Dom{\rho}_\SymSets}"]
        \arrow[dr, swap, "\IMode{\mathfrak{s}}"] &&
      \IMode{\Dom{V}_\SymSets}
      \arrow[dl, "\IMode{\mathfrak{t}}"] \\
      &\IMode{\Sorts}
    \end{tikzcd}
  \]

  Because the object $\Of{*}{\mathbb{1}}$ is unique, we will always omit it
  from the data of an object in $\SCtx$.
\end{remark}

\paragraph{Presheaves on $\SCtx$}

A presheaf on a category $\mathcal{C}$ is a contravariant functor
$\OpCat{\mathcal{C}}\ra\Sets$; when $\Match{\mathcal{C}}{\OpCat{\mathcal{D}}}$,
we call this a \emph{copresheaf} (covariant presheaf) on $\mathcal{D}$.
Therefore, a copresheaf on $\SCtx$ is a functor $\SCtx\ra\Sets$; colloquially,
such a copresheaf can be thought of as a set that \emph{varies over} symbol
contexts.

This leads to a very intuitive setting in which to consider sets
that vary over collections of $\Sorts$-sorted symbols. In particular, for any
morphism
%
\begin{tikzcd}[cramped]
  \IMode{\Upsilon}\arrow[r, hook, "\IMode{\varrho}"] & \IMode{\Upsilon'}
\end{tikzcd}
%
in $\SCtx$, we have a corresponding functorial renaming action on any
copresheaf $\Of{X}{\Sets^\SCtx}$, namely $\Of{X(\varrho)}{X(\Upsilon)\ra
X(\Upsilon')}$. When the copresheaf $X$ is clear from context, we will write
$m\cdot\varrho$ for $X(\varrho)(m)$.

Now, when $\Member{m}{X(\Upsilon)}$ for a copresheaf $\Of{X}{\Sets^\SCtx}$, we
can define the notion that $m$ depends on \emph{at most} a subcontext
$\Upsilon'$ of $\Upsilon$; this is called \emph{support}.

\begin{definition}[Support]
  \label{def:support}
  When
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon}\arrow[r, hook, "\IMode{\varrho}"] & \IMode{\Upsilon'}
  \end{tikzcd},
  we say that $\Upsilon$ supports $\Member{m}{\Upsilon'}$ (written
  $\Supports{\Upsilon}{\varrho}{m}$) when, for all
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon'}\arrow[r, hook, "\IMode{\varrho_1}{,} \IMode{\varrho_2}"] & \IMode{\Upsilon''}
  \end{tikzcd},
  if $\IsEq{\varrho_1\circ\varrho}{\varrho_2\circ\varrho}$ then $\IsEq{m\cdot\varrho_1}{m\cdot\varrho_2}$.
\end{definition}

We can also always calculate the \emph{least support} of a term
$\Member{m}{X(\Upsilon')}$, written $\Supp{m}$:
\[
  \Define{\Supp{m}}{
    \bigcap_{
      \begin{tikzcd}[cramped, ampersand replacement = \&]
        \Upsilon\arrow[r, hook, "\varrho"] \& \Upsilon'
      \end{tikzcd}
    }
    \MkSet{
      \Upsilon
      \mid
      \SupportsUnmoded{\Upsilon}{\varrho}{m}
    }
  }
\]
Intuitively, $\Supp{m}$ is the exact symbol context that $m$ depends on.

\subsection{Sheaves on the atomic site}

Intuitively, when $\Upsilon$ supports $\Member{m}{X(\Upsilon')}$, we would
expect that we can work backward to a unique $\Of{m'}{\Upsilon}$ such that
$\IsEq{m'\cdot\varrho}{m}$; whilst it is not in general the case for presheaves
$X$, this is precisely the sheaf condition for copresheaves on $\SCtx$
under the atomic topology \cite[p.~126]{mac-lane-moerdijk:1992}. The sheaf
condition, then, ensures that the notion of support is well-behaved.

\paragraph{Sites and coverages}

We will briefly discuss the basics of sheaves on a site. A \emph{site} is a
pair $\Pair{\mathcal{C}}{J}$, with $\mathcal{C}$ a category of ``worlds'' and
$J$ a Grothendieck topology (or ``coverage''). A coverage is a predicate that
picks out for each object $\Of{C}{\mathcal{C}}$, the \emph{covering sieves} of
$C$, subject to several axioms (see \cite{mac-lane-moerdijk:1992} for details).

\paragraph{Covering sieves and matching families}

A \emph{sieve} on an object $C$ is a subfunctor of the Yoneda embedding
$\Define{\Yoneda{C}}{\Hom{\mathcal{C}}{-}{C}}$. We say that such a sieve $S$
covers $C$ just when $\Member{S}{J(C)}$.  For a presheaf $X$ on the site
$\Pair{\mathcal{C}}{J}$, a \emph{matching family} for the sieve $S$ is a
natural transformation $\Of{\phi}{S\ra X}$. An \emph{amalgamation} for $\phi$
is an object $\Member{m}{X(C)}$ such that $\IsEq{m\cdot f}{\phi_D(f)}$ for each
$\Member{f}{S(D)}$, for all objects $D$.

\paragraph{Separation and sheafhood}
Then, we say that the presheaf $X$ is \emph{separated} in case for every sieve
$\Member{S}{J(C)}$ and matching family $\Of{\phi}{S\ra X}$, there is at most
one amalgamation $\Member{m}{X(C)}$ for $\phi$. Additionally, $X$ is called a
\emph{sheaf} when there is \emph{exactly one} such amalgamation.

\paragraph{The atomic coverage}

The atomic coverage $J_\mathsf{atm}$ is the one in which all non-empty sieves
cover. A sieve $\IMode{S}\sqsubseteq\IMode{\Yoneda{C}}$ is non-empty when the
collection $\bigcup_D S(D)$ of all its arrows is non-empty.

In the future, we will write $\SCtxSite$ for the Grothendieck site
$\Pair{\OpCat{\left(\SCtx\right)}}{J_\mathsf{atm}}$, where $J_\mathsf{atm}$ is
the atomic coverage. Sheafhood on the atomic site $\SCtxSite$ amounts to the
following condition, using Definition~\ref{def:support}:
\begin{quote}
  A presheaf $\Of{X}{\Sets^\SCtx}$ is a sheaf on $\SCtxSite$ just when, for all $\Member{n}{X(\Upsilon')}$, if we have
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon}\arrow[r, hook, "\IMode{\varrho}"] & \IMode{\Upsilon'}
  \end{tikzcd}
  and $\Supports{\Upsilon}{\varrho}{n}$, then there is a unique
  $\Member{m}{X(\Upsilon)}$ such that $\IsEq{m\cdot\varrho}{n}$.
\end{quote}

Therefore, a sheaf on $\SCtxSite$ is a set that varies over $\Sorts$-sorted
symbols, which has a well-behaved notion of support. Another way to put it is,
if $\Member{m}{X(\Upsilon)}$ only ``uses'' some of the symbols available at
world $\Upsilon$, there's a canonical way to restrict $m$ to a term in the
world which contains \emph{only} the symbols that it uses.

\subsection{Constructions on sheaves}

For any Grothendieck site $\Match{\mathfrak{S}}{\Pair{\mathcal{C}}{J}}$, the
inclusion $\Of{\iota}{\Sheaves{\mathfrak{S}}\ra\Presheaves{\mathcal{C}}}$ of
sheaves into presheaves has a left adjoint
$\IMode{\Sheafify{(-)}}\dashv\IMode{\iota}$, which takes any presheaf
$\Of{X}{\Presheaves{\mathcal{C}}}$ to a unique sheaf
$\Of{\Sheafify{X}}{\Sheaves{\mathfrak{S}}}$, called the \emph{sheafification}
of $X$. Sheafification is the twice-iterated application of the
\emph{+-construction} $X^+$, which turns a presheaf into a separated presheaf,
and a separated presheaf into a sheaf \cite{mac-lane-moerdijk:1992}:
\begin{align*}
  \ADefine{
    X^+(C)
  }{
    \int^{S\in J(C)}
    \Hom{\Presheaves{\mathcal{C}}}{S}{X}
  }\\
  \ADefine{
    \Sheafify{X}
  }{
    X^{++}
  }
\end{align*}

We also have a canonical natural transformation $\Of{\eta}{X\ra X^+}$, defined
using the maximal sieve $\Define{t_C}{\Yoneda{C}}$:
\[
  \HypJ{
    \Define{\eta_C(m)}{
      \Pair{t_C}{
        X(-)(m)
      }
    }
  }{
    \Member{m}{X(C)}
  }
\]


Every category of sheaves on a site gives rise to a topos, which equips us with
a number of standard constructions, including (among other things) the disjoint
union of sheaves $X\oplus Y$, the product of sheaves $X\otimes Y$, and the terminal sheaf $\mathbb{1}$.

Returning to the site $\SCtxSite$, we will write $\mathbf{S}_\tau$ for the sheaf
of symbols of sort $\tau$, a subobject of the Yoneda embedding of the empty
symbol context, $\Yoneda{\cdot}$.

\subsection{Relation to Nominal Sets and the Schanuel Topos}

Pitts defines a category $\mathbf{Nom}$ of nominal sets in \cite{pitts:2013}
which function equivalently to the sheaves that we considered above, in the
case of $\IMode{\Sorts}\cong\IMode{\mathbb{1}}$. Fix a countably infinite set
of atoms $\mathbb{A}$; then let $\Perm\mathbb{A}$ be the group of permutations
(i.e.\ autoequivalences) on $\mathbb{A}$.  Considered as a category,
$\Perm\mathbb{A}$ has a single object $\bullet$ with morphisms
$\Of{\pi}{\bullet\ra\bullet}$ for each $\Member{\pi}{\Dom{\Perm\mathbb{A}}}$.
Then, the category of nominal sets $\mathbf{Nom}$ is the subcategory of
$\Sets^{\Perm\mathbb{A}}$ containing just the presheaves which satisfy a
\emph{finite support} condition.

The category $\mathbf{Nom}$ is equivalent to the category of covariant sheaves
on $\SymSets$ under the atomic coverage, called the Schanuel Topos
$\Define{\mathbb{S}}{\Sheaves{\OpCat{\SymSets}}}$ \cite{pitts:2013,
fiore-staton:2006}; equivalently, the Schanuel topos is the subcategory of
$\Sets^\SymSets$ containing only pullbacks-preserving functors.

In addition to the unisorted nominal sets framework, Pitts also briefly
discusses a multi-sorted version of the apparatus in which the countably
infinite set of atoms $\mathbb{A}$ is equipped with a sort assignment
$\Of{\mathfrak{s}}{\mathbb{A}\to\Sorts}$ such that all the fibres of
$\mathfrak{s}$ are countably infinite; then, he defines for any such assignment
the category $\mathbf{Nom}_\mathfrak{s}$ of $\mathfrak{s}$-sorted nominal sets
as a subcategory of the category of presheaves on the group of
$\mathfrak{s}$-respecting permutations on $\mathbb{A}$,
$\Perm_\mathfrak{s}\mathbb{A}$.

In the same way as the Schanuel topos is equivalent to the unisorted nominal
sets, we expect to find an equivalence between $\Sheaves{\SCtxSite}$ and the
limit $\int_{\mathfrak{s}}\mathbf{Nom}_\mathfrak{s}$. At the very least, the
sheaf topos $\Sheaves{\SCtxSite}$ may serve as a multi-sorted generalization of
the Schanuel topos, for which we may carry over certain useful results,
including its characterization as the subcategory of $\Sets^\SCtx$ which
contains just the pullbacks-preserving functors (see
Theorem~\ref{thm:pullback-preservation} for the proof).


\section{Operators and signatures}

A valence $\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}$ specifies an expression
of sort $\tau$ which binds symbols in $\vec{\sigma}$ and variables in
$\vec{\tau}$.

\[
  \infer{
    \IsValence{
      \MkValence
        {\sigma_0,\dots,\sigma_m}
        {\tau_0,\dots,\tau_n}
        {\tau}
    }
  }{
    \IsSort{\tau}
&
    \HypJ{\IsSort{\sigma_i}}{\Leq{i}{m}}
&
    \HypJ{\IsSort{\tau_i}}{\Leq{i}{n}}
  }
\]

An arity $\MkArity{\vec{v}}{\tau}$ specifies an operator of sort $\tau$ with
arguments of valences $\vec{v}$. We will call the set of valences $\Valences$,
and the set of arities $\Arities$.

\[
  \infer{
    \IsArity{
      \MkArity
        {v_0,\ldots,v_n}
        {\tau}
    }
  }{
    \IsSort{\tau}
&
    \HypJ
      {\IsValence{v_i}}
      {\Leq{i}{n}}
  }
\]


Fix a family of sheaves of operators
$\Member{\Operators_a}{\Sheaves{\SCtxSite}}$, indexed by arities
$\Member{a}{\Arities}$; for each $\Operators_a$, arrows in $\SCtx$ will lift to
renamings in operators' symbolic parameters. Together, $\Sorts$ and $\Operators$ are said to form a \emph{signature}
$\Define{\Sigma}{\Pair{\Sorts}{\Operators}}$.

We will write $\IsOperator{\Upsilon}{\vartheta}{a}$ in case
$\Member{\vartheta}{\Operators_a(\Upsilon)}$; note that this judgment enjoys
the structural properties of weakening and exchange via functoriality of
$\Operators$. An operator signature is defined by specifying, for each arity
$a$, the sheaf $\Operators_a$, whose ``elements'' are the operators of arity
$a$.


\paragraph{Examples}

For instance, consider a $\lambda$-calculus with a single sort, $\SortExp$; we
give its signature $\Sigma_{\lambda}$ by asserting the following about its
operators:
\begin{gather*}
  \IsOperator{\Upsilon}{\mathtt{lam}}{
    \MkArity{
      \MkValence{}{\SortExp}{\SortExp}
    }{\SortExp}
  }\\
  \IsOperator{\Upsilon}{\mathtt{fix}}{
    \MkArity{
      \MkValence{}{\SortExp}{\SortExp}
    }{\SortExp}
  }\\
  \IsOperator{\Upsilon}{\mathtt{ap}}{
    \MkArity{
      \MkValence{}{}{\SortExp},
      \MkValence{}{}{\SortExp}
    }{\SortExp}
  }
\end{gather*}

These rules correspond to the following definition of $\Operators$:
\begin{align*}
  \ADefine{
    \Operators_{
       \MkArity{
        \MkValence{}{\SortExp}{\SortExp}
      }{\SortExp}
    }
  }{
    \mathbb{1}\oplus\mathbb{1}
  }
  \\
  %
  \ADefine{
    \Operators_{
      \MkArity{
        \MkValence{}{}{\SortExp},
        \MkValence{}{}{\SortExp}
      }{\SortExp}
    }
  }{
    \mathbb{1}
  }
\end{align*}

So far, we have made no use of symbols and parameters; however, consider the
extension of the calculus with assignables (references):
%
\begin{gather*}
  \IsOperator{\Upsilon}{\mathtt{decl}}{
    \MkArity{
      \MkValence{}{}{\SortExp},
      \MkValence{\SortExp}{}{\SortExp}
    }{
      \SortExp
    }
  }
\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathtt{get}[u]}{
    \MkArity{}{\SortExp}
  }
\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathtt{set}[u]}{
    \MkArity{
      \MkValence{}{}{\SortExp}
    }{
      \SortExp
    }
  }
\end{gather*}

These rules correspond to the following family of sheaves:
\begin{align*}
  \ADefine{
    \Operators_{
      \MkArity{
        \MkValence{}{}{\SortExp},
        \MkValence{\SortExp}{}{\SortExp}
      }{
        \SortExp
      }
    }
  }{
    \mathbb{1}
  }\\
  \ADefine{
    \Operators_{
      \MkArity{}{\SortExp}
    }
  }{
    \mathbf{S}_\SortExp
  }\\
  \ADefine{
    \Operators_{
      \MkArity{
        \MkValence{}{}{\SortExp}
      }{
        \SortExp
      }
    }
  }{
    \mathbf{S}_\SortExp
  }
\end{align*}

Declaring a new assignable consists in providing an initial value, and an
expression binding a symbol (which shall represent the assignable in scope).
Note that the functoriality of $\Operators$ guarantees for any renaming
$\Of{\varrho}{\Upsilon\inj\Upsilon'}$, a family of lifted maps
$\Of{\Operators_a(\varrho)}{\Operators_a(\Upsilon)\inj\Operators_a(\Upsilon')}$
natural in $a$, such that
$\IsOperator{\Upsilon'}{\Operators(\varrho)(\vartheta)}{a}$ when
$\IsOperator{\Upsilon}{\vartheta}{a}$. In particular, the renaming
$\Upsilon,u\mapsto\Upsilon,v$ shall take $\mathtt{get}[u]$ to
$\mathtt{get}[v]$. Going forward, we will write $\vartheta\varrho$ for
$\Operators_a(\varrho)(\vartheta)$.


\section{Contexts}

In general, we will have three kinds of context: symbolic (parameter) contexts,
variable contexts, and metavariable contexts. The symbol contexts have already
been defined via the comma construction $\SCtx$, but they also admit a
syntactic characterization,
\begin{gather*}
  \infer{
    \IsSymCtx{\cdot}
  }{
  }
\qquad
  \infer{
    \IsSymCtx{\Upsilon,u:\tau}
  }{
    \IsSymCtx{\Upsilon}
&
    \IsSort{\tau}
&
    \NotIn{u}{\Dom\Upsilon}
  }
\end{gather*}
%
Because, modulo notation, we have $\Member{\Upsilon}{\SCtx}$ just when
$\IsSymCtx{\Upsilon}$, we will use the syntactic view when it is convenient.

Contexts of variables are similar to contexts of symbols, except that they
admit \emph{any} renamings, not just the injective ones. As such, when
$\FinSets$ is the category of finite cardinals and all functions between them, the
comma construction $\Ctx$ is the category of variable contexts. As above, we
can give them an equivalent syntactic treatment:
\begin{gather*}
  \infer{
    \IsVarCtx{\cdot}
  }{
  }
\qquad
  \infer{
    \IsVarCtx{\Gamma,x:\tau}
  }{
    \IsVarCtx{\Gamma}
&
    \IsSort{\tau}
&
    \NotIn{x}{\Dom\Gamma}
  }
\end{gather*}

A metavariable context consists of bindings of \emph{valences} to
metavariables; let $\Define{\Valences}{\MkSet{v\mid \IsValenceUnmoded{v}}}$ be the set
of valences. Then, the category of metavariable contexts is the comma
construction $\MCtx$, which likewise admits an equivalent inductive definition:
\begin{gather*}
  \infer{
    \IsMetaCtx{\cdot}
  }{
  }
\qquad
  \infer{
    \IsMetaCtx{\Theta,\MV{m}:v}
  }{
    \IsMetaCtx{\Theta}
&
    \IsValence{v}
&
    \NotIn{\MV{m}}{\Dom\Theta}
  }
\end{gather*}



\section{Nominal Abstract Binding Trees}

Let the judgment $\IsAbt{\Theta}{\Upsilon}{\Gamma}{M}{\tau}$ presuppose
\footnote{
  In the \emph{judgmental method}, as pioneered by Per Martin-L\"of, a form of
  judgment is propounded first by specifying its range of significance (i.e.\
  the circumstances under which it shall have a meaning), and then, a meaning
  explanation (definition) for the judgment is given. The range of significance
  of a judgment is called its \emph{presupposition}, and the meaning of the
  judgment may proceed by induction on the evidence that the presupposition
  obtains. See \cite{schroeder-heister:1987} for a more detailed explanation of
  presuppositions and the judgmental method.
}
$\IsMetaCtx{\Theta}$, $\IsSymCtx\Upsilon$, $\IsVarCtx\Gamma$ and
$\IsSort{\tau}$, meaning that $M$ is an abstract binding tree of sort $s$, with
metavariables in $\Theta$, parameters in $\Upsilon$, and variables in $\Gamma$.
Let the judgment $\IsBTm{\Theta}{\Upsilon}{\Gamma}{E}{v}$ presuppose
$\IsValence{v}$. Then, the syntax of abstract binding trees is inductively
defined in four rules:

\[
  \infer[\textit{var}]{
    \IsAbt{\Theta}{\Upsilon}{\Gamma}{x}{\tau}
  }{
    \Lookup{\Gamma}{x}{\tau}
  }
\]
\[
  \infer[\textit{mvar}]{
    \IsAbt{\Theta}{\Upsilon}{\Gamma}{
      \MApp{\MV{m}}{u_0,\dots,u_m}{M_0,\dots,M_n}
    }{\tau}
  }{
    \begin{array}{l}
      \Lookup{\Theta}{\MV{m}}{
        \MkValence{
          \sigma_0,\dots,\sigma_m
        }{
          \tau_0,\dots,\tau_n
        }{\tau}
      }
\\
      \HypJ{
        \Lookup{\Upsilon}{u_i}{\sigma_i}
      }{\Leq{i}{m}}
\\
      \HypJ{
        \IsAbt{\Theta}{\Upsilon}{\Gamma}{M_i}{\tau_i}
      }{\Leq{i}{n}}
    \end{array}
  }
\]
\[
  \infer[\textit{app}]{
    \IsAbt{\Theta}{\Upsilon}{\Gamma}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{\tau}
  }{
    \begin{array}{l}
      \IsOperator{\Upsilon}{\vartheta}{
        \MkArity{v_1,\dots,v_n}{\tau}
      }
\\
      \HypJ{
        \IsBTm{\Theta}{\Upsilon}{\Gamma}{E_i}{v_i}
      }{\Leq{i}{n}}
    \end{array}
  }
\]
\[
  \infer[\textit{abs}]{
    \IsBTm{\Theta}{\Upsilon}{\Gamma}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}
    }
  }{
    \IsAbt{
      \Theta
    }{
      \Upsilon, \vec{u}:\vec{\sigma}
    }{
      \Gamma,\vec{x}:{\vec{\tau}}
    }{
      M
    }{\tau}
  }
\]

Abts are identified up to $\alpha$-equivalence.

\subsection{Calculating free variables}

We can easily calculate the variables free in an expression by recursion on its
structure:

\begin{gather*}
  \infer[\textit{var}]{
    \CalcFV{x}{\MkSet{x}}
  }{
  }\\[6pt]
  %
  \infer[\textit{mvar}]{
    \CalcFV{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \bigcup_{i\leq n} \vec{x}_i
    }
  }{
    \HypJ{
      \CalcFV{M_i}{\vec{x}_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %
  \infer[\textit{app}]{
    \CalcFV{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \bigcup_{i\leq n} \vec{x}_i
    }
  }{
    \HypJ{
      \CalcFV{E_i}{\vec{x}_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %
  \infer[\textit{abs}]{
    \CalcFV{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \vec{x}\setminus\vec{y}
    }
  }{
    \CalcFV{M}{\vec{x}}
  }
\end{gather*}

Because this is a total relation, henceforth we will write $\FV{M}$ for
$\vec{x}$ when $\CalcFV{M}{\vec{x}}$.

\subsection{Calculating free symbols}

Whereas the calculation of free variables pivoted on the \emph{var} rule, the
calculation of free symbols will pivot on the \emph{app} and \emph{mvar} rule,
because the only way a symbol can be introduced is as a parameter to an
operator or as a parameter to a metavariable.

\begin{gather*}
  \infer[\textit{var}]{
    \CalcFS{x}{\MkSet{}}
  }{
  }\\[6pt]
  %
  \infer[\textit{mvar}]{
    \CalcFS{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \vec{u} \cup \bigcup_{i\leq n} \vec{u}_i
    }
  }{
    \HypJ{
      \CalcFS{M_i}{\vec{u}_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %
  \infer[\textit{app}]{
    \CalcFS{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \Dom{\Supp{\vartheta}} \cup \bigcup_{i\leq n} \vec{u}_i
    }
  }{
    \HypJ{
      \CalcFS{E_i}{\vec{u}_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %
  \infer[\textit{abs}]{
    \CalcFS{
      \MkBTm{\vec{v}}{\vec{x}}{M}
    }{
      \vec{u}\setminus\vec{v}
    }
  }{
    \CalcFS{M}{\vec{u}}
  }
\end{gather*}

Because this is a total relation, henceforth we will write $\FS{M}$ for
$\vec{u}$ when $\CalcFS{M}{\vec{u}}$.


\subsection{Renaming of symbols}

The only place that symbols appear in our calculus is as parameters to operators
(unlike variables, symbols are not terms). Therefore, the functorial action of
the operator sheaf can be lifted into terms by recursion on their
structure, via a pair of judgments $\IsRenaming{\varrho}{M}{N}$ and
$\IsRenaming{\varrho}{E}{F}$, presupposing $\Of{\varrho}{\Upsilon\inj\Upsilon'}$,
and $\IsAbt{\Theta}{\Upsilon}{\Gamma}{M}{\tau}$ and
$\IsAbt{\Theta}{\Upsilon}{\Gamma}{E}{v}$ respectively:

\begin{gather*}
  \infer[\textit{var}]{
    \IsRenaming{\varrho}{x}{x}
  }{
  }
\\[6pt]
  \infer[\textit{mvar}]{
    \IsRenaming{\varrho}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{v}}{N_0,\dots,N_n}
    }
  }{
    \Match{\varrho(\vec{u})}{\vec{v}}
&
    \HypJ{
      \IsRenaming{\varrho}{M_i}{N_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer[\textit{app}]{
    \IsRenaming{\varrho}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta\varrho}{F_0,\dots,F_n}
    }
  }{
    \HypJ{
      \IsRenaming{\varrho}{E_i}{F_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer[\textit{abs}]{
    \IsRenaming{\varrho}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }
  }{
    \IsRenaming{\varrho\setminus\vec{u}}{M}{N}
  }
\end{gather*}

Above, the notation $\varrho\setminus\vec{u}$ means the omission of the
variables $\vec{u}$ from the renaming $\varrho$. Because terms are identified up
to $\alpha$-equivalence, the renaming judgment is functional in its input, and
so we are justified in writing $\Rename{\varrho}{M}$ for $N$ when
$\IsRenaming{\varrho}{M}{N}$.

\subsection{Substitution of variables}

Variable substitution in abts is defined inductively by a pair of judgments,
$\IsSubst{N}{x}{M}{M'}$ and $\IsSubst{N}{x}{E}{F}$:

\begin{gather*}
  \infer[\textit{var}_1]{
    \IsSubst{N}{x}{y}{N}
  }{
    \IsEq{x}{y}
  }
\qquad
  \infer[\textit{var}_2]{
    \IsSubst{N}{x}{y}{y}
  }{
    \IsApart{x}{y}
  }
\\[6pt]
  \infer[\textit{mvar}]{
    \IsSubst{N}{x}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{u}}{M'_0,\dots,M'_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{M_i}{M'_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer[\textit{app}]{
    \IsSubst{N}{x}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta}{F_0,\dots,F_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{E_i}{F_i}
    }{
      \Leq{i}{n}
    }
  }
\end{gather*}
\begin{gather*}
  \infer[\textit{abs}_1]{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M'}
    }
  }{
    \NotIn{x}{\vec{y}}
&
    \IsApart{\vec{u}}{\FS{N}}
&
    \IsApart{\vec{y}}{\FV{N}}
&
    \IsSubst{N}{x}{M}{M'}
  }
\\[6pt]
  \infer[\textit{abs}_2]{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }
  }{
    \Member{x}{\vec{y}}
&
    \IsApart{\vec{u}}{\FS{N}}
&
    \IsApart{\vec{y}}{\FV{N}}
  }
\end{gather*}

Going forward, we will write $\Subst{N}{x}{M}$ for $M'$ when
$\IsSubst{N}{x}{M}{M'}$, and $\Subst{\vec{N}}{\vec{x}}{M}$ for the simultaneous
substitution of $\vec{N}$ for $\vec{x}$ in $M$.

\subsection{Substitution of metavariables}

Metavariables are substituted by bound terms; since a metavariable may only
appear in an application expression $\MApp{\MV{m}}{\cdots}{\cdots}$, we will
instantiate the bound term at the supplied parameters and arguments.
Substitution for metavariables is defined inductively by the judgments
$\IsSubst{E}{\MV{m}}{M}{N}$ and $\IsSubst{E}{\MV{m}}{F}{F'}$:

\begin{gather*}
  \infer[\textit{var}]{
    \IsSubst{E}{\MV{m}}{x}{x}
  }{
  }
\\[6pt]
  \infer[\textit{mvar}_1]{
    \IsSubst{E}{\MV{m}}{
      \MApp{\MV{n}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{n}}{\vec{u}}{N_0,\dots,N_n}
    }
  }{
    \IsApart{\MV{m}}{\MV{n}}
&
    \HypJ{
      \IsSubst{E}{\MV{n}}{M_i}{N_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer[\textit{mvar}_2]{
    \IsSubst{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }{\MV{m}}{
      \MApp{\MV{n}}{\vec{v}}{\vec{M}}
    }{
      N''
    }
  }{
    \IsEq{\MV{m}}{\MV{n}}
&
    \IsSubst{\vec{M}}{\vec{x}}{N}{N'}
&
    \IsRenaming{\vec{u}\mapsto\vec{v}}{N'}{N''}
  }\\[6pt]
  %
  \infer[\textit{app}]{
    \IsSubst{E}{\MV{m}}{
      \App{\vartheta}{F_0,\dots,F_n}
    }{
      \App{\vartheta}{F'_0,\dots,F'_n}
    }
  }{
    \HypJ{
      \IsSubst{E}{\MV{m}}{F_i}{F'_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer[\textit{abs}]{
    \IsSubst{E}{\MV{m}}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }
  }{
    \IsApart{\vec{u}}{\FS{E}}
&
    \IsApart{\vec{x}}{\FV{E}}
&
    \IsSubst{E}{\MV{m}}{M}{N}
  }
\end{gather*}

As usual, we will write $\Subst{E}{\MV{m}}{M}$ for $N$ when
$\IsSubst{E}{\MV{m}}{M}{N}$.

\section{Model Theory}

Let $\Define{\HypCat}{\OpCat{(\SCtx\times\Ctx)}}$; then we fix the functor
category $\widehat{\HypCat}^\Sorts$ as our semantic universe.

Let $\Define{V_\tau(\Upsilon\parallel\Gamma)}{\MkSet{x\in\Dom\Gamma\mid
    \Gamma(x)=\tau}}$ be called the presheaf of variables; additionally, we have
a presheaf of symbols
$\Define{S_\tau(\Upsilon\parallel\Gamma)}{\MkSet{u\in\Dom\Upsilon\mid
    \Upsilon(x)=\tau}}$. Lastly, we have the presheaf of operators with arity
$a$,
$\Define{\Operators_a(\Upsilon\parallel\Gamma)}{\Operators_a(\Upsilon)}$

\subsection{Substitution monoidal structures}
\newcommand\SymPsh{\mathbf{S}}
\newcommand\VarPsh{\mathbf{V}}

For an object $\Of{P}{\widehat{\HypCat}^\Sorts}$, we will use the notation
$P^{[\Gamma]}$ to mean $\prod_{x\in\Dom\Gamma}P_{\Gamma(x)}$; likewise,
$\SymPsh^{\{\Upsilon\}}$ shall mean $\prod_{u\in\Dom\Upsilon}S_{\Upsilon(u)}$. For a
presheaf $\Of{A}{\widehat{\HypCat}}$ and a sort-indexed family of presheaves
$\Of{P}{\widehat{\HypCat}^\Sorts}$, we have an operation $A\bullet P$, defined
as a coend in the following way:
\[
  \Define{(A\bullet P)(\Upsilon\parallel\Gamma)}{
    \int^{(\Upsilon'\parallel\Delta)\in\HypCat}
      A(\Upsilon'\parallel\Delta)
      \times \SymPsh^{\{\Upsilon'\}}(\Upsilon\parallel\Gamma)
      \times P^{[\Delta]}(\Upsilon\parallel\Gamma)
  }
\]

Using this, we can define a tensor $P\odot Q$ for
$\Of{P,Q}{\widehat{\HypCat}^\Sorts}$ as follows:
\[
  \HypJ{
    \Define{{(P\odot Q)}_{\tau}}{
      P_\tau\bullet Q
    }
\quad
  }{
    \Member{\tau}{\Sorts}
  }
\]

Then, $V$ is the unit to this tensor. We will say that an object
$\Of{P}{\widehat{\HypCat}^\Sorts}$ is a $\Sigma$-monoid in case it is equipped
with the following natural transformations where $\nu$ embeds variables into $P$
and $\varsigma$ equips $P$ with an operation for simultaneous substitutions of
variables. Furthermore, $\nu$ and $\varsigma$ induce maps ${\nu}_{\Gamma}$ and
${\varsigma}^{\tau}_{\Upsilon\parallel\Gamma}$:
\begin{gather*}
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{V}} \arrow[r, "\IMode\nu"]
    \&
    {\IMode{P}}
    \&
    {\IMode{P\odot P}}
      \arrow[l, swap, "\IMode\varsigma"]
  \end{tikzcd}\\[6pt]
  %
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{{V}^{[\Gamma]}}}
      \arrow[r, "\IMode{{\nu}_{\Gamma}}"]
    \&
    {\IMode{{P}^{[\Gamma]}}}
  \end{tikzcd}
  \qquad
  \begin{tikzcd}[cramped, sep = large, ampersand replacement = \&]
    {\IMode{{P_\tau^{\Yoneda{\Upsilon\parallel\Gamma}}\times \SymPsh^{\{\Upsilon\}}\times P^{[\Gamma]}}}}
      \arrow[r, "\IMode{\varsigma^\tau_{\Upsilon\parallel\Gamma}}"]
    \&
    {\IMode{P_\tau}}
  \end{tikzcd}
\end{gather*}

\subsection{The signature endofunctor and its initial algebras}

For each signature $\Match{\Sigma}{\Pair{\Sorts}{\Operators}}$, we have an
endofunctor
$\Of{\SigFun{\Sigma}}{\widehat{\HypCat}^\Sorts\ra\widehat{\HypCat}^\Sorts}$,
which is defined as follows:
\begin{align*}
  \IMode{{\SigFun{\Sigma}(X)}_{\tau}}
&
    \triangleq
    \OMode{
      \coprod_{
        \vartheta\in \Operators_{\MkArity{\vec{v}}{\tau}}
      }
      \prod_{
        \MkValence
          {\vec{\sigma}}
          {\vec{\tau}}
          {\tau_i}
        \in\vec{v}
      }
      X_{\tau_i}^{\Yoneda{\vec{\sigma}\parallel\vec{\tau}}}
    }
\end{align*}

Then, a $\Sigma$-model is a $\Sigma$-monoid $P$ which is equipped with an
initial algebra $\Of{\alpha}{\SigFun{\Sigma}(P)\ra P}$, which shall interpret
applications of each operator.

\subsection{Interpretation of terms}

The metavariable, symbol and variable contexts are interpreted for a model $P$ as
an environment presheaf in the following way:
\[
  \Define{
    \SemBrackets{
      \Theta\triangleright\Upsilon\parallel\Gamma
    }_P
  }{
    \left(
      \prod_{
        (m:%
        \MkValence
          {\vec{\sigma}}
          {\vec{\tau}}
          {\tau})
        \in\Theta
      }{{P_{\tau}}^{\Yoneda{\vec{\sigma}\parallel\vec{\tau}}}}
    \right)
    \times
    \SymPsh^{\{\Upsilon\}}
    \times
    \VarPsh^{[\Gamma]}
  }
\]

Then, the interpretation of a term in a model $P$ is a map from its environment
to $P$:
\[
  \Of{
    \SemBrackets{
      \Theta\triangleright\Upsilon\parallel\Gamma\vdash M:\tau
    }_{P}
  }{
    \SemBrackets{
      \Theta\triangleright\Upsilon\parallel\Gamma
    }_{P}\ra {P}_{\tau}
  }
\]

Variables are interpreted by the map
${\SemBrackets{
  \Theta\triangleright\Upsilon\parallel\Gamma\vdash x:\tau
}}_{P}$ which
projects them from the environment and embeds them into the model. Metavariables
are resolved by the map
${\SemBrackets{
  \Theta\triangleright\Upsilon\parallel\Gamma\vdash\MApp{\MV{m}}{\vec{u}}{\vec{M}}
  : \tau
}}_{P}$ (where
$\Lookup{\Theta}{\MV{m}}{\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}}$) which
projects their interpretation from the environment and instantiates it via
substitution:
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{P_\tau}}
\&[8.0em]
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , rr
        , dashed
        , "
          \OMode{
            {\SemBrackets{
              \Theta\triangleright\Upsilon\parallel\Gamma
              \vdash
              x:\tau
            }}_{P}
          }
          "
      ]
      \ar{drr}[
        , rotate = -16.5
        , xshift = +1.5em
        , yshift = -0.2em
        , swap
      ]{
        {\nu}_{\Gamma} {\pi}_{3}
      }
      \ar{dl}[
        , rotate = +11.5
        , xshift = -2.75em
      ]{
        \IMode{
          \Tuple{
            \pi_\MV{m}\,
            \pi_1,
            \phi\,
            \pi_2,
            \psi
          }
        }
      }
      \arrow[
        , l
        , dashed
        , swap
        , "
          \OMode{
            {\SemBrackets{
              \Theta\triangleright\Upsilon\parallel\Gamma
              \vdash
              \MApp{\MV{m}}{\vec{u}}{\vec{M}}: \tau
            }}_{P}
          }"
      ]
\&[-2.0em]
    \null
\&[+3.0em]
    {\IMode{P_\tau}}
\\
    {\IMode{
      {P}_{\tau}^{
        \Yoneda{\vec{\sigma}\parallel\vec{\tau}}
      }
      \times \SymPsh^{\{\vec{\sigma}\}}
      \times P^{[\vec{\tau}]}
    }}
      \arrow[
        , u
        , "
          \IMode{
            \varsigma^\tau_{\vec{\sigma}\parallel\vec{\tau}}
          }
          "
        ]
\&
    \null
\&
    \null
\&
    {\IMode{P^{[\Gamma]}}}
      \arrow[
        , u
        , swap
        , "{\pi}_{x}"
      ]
\\
    {\IMode{P^{[\vec{\tau}]}}}
\&
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , dashed
        , l
        , swap
        , "
          \Define{
            \psi\,
          }{
            \,\Tuple{
              {\SemBrackets{
                \Theta\triangleright\Upsilon\parallel\Gamma\vdash M:\tau
              }}_{P}
            }_{(M,\tau)\in (\vec{M},\vec{\tau})}
          }
          "]
\&
    {\IMode{\SymPsh^{\{\Upsilon\}}}}
      \arrow[
        , dashed
        , r
        , "\Define{\phi\,}{\,\Tuple{\pi_u}_{u\in\vec{u}}}"
      ]
\&
    {\IMode{\SymPsh^{\{\vec{\sigma}\}}}}
  \end{tikzcd}
\]

Interpretation of operator applications is the most complicated. Recall that,
unlike in standard treatments of universal algebra, our operators are indexed by
symbol collections; therefore, operators must pass through suitable renamings in
order to be used in the interpretation. Let us begin by constructing for each
operator $\IsOperator{\Upsilon}{\vartheta}{a}$ the morphism
$\SemBrackets{\vartheta}_P$ which shall rename the parameters of the operator
using the environment:
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&, sep = huge]
    |[alias = Src]|
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , r
        , swap
        , "\IMode{\pi_2}"
      ]
\&
    {\IMode{\SymPsh^{\{\Upsilon\}}}}
      \arrow[
        , r
        , swap
        , "\IMode{\Operators_a(\pi_{(-)})(\vartheta)}"
      ]
\&[1.5em]
    |[alias = Tgt]|
    {\IMode{\Operators_a}}
      \arrow[
        , from = Src
        , to = Tgt
        , bend left
        , dashed
        , "\OMode{\SemBrackets{\vartheta}_{P}}"
      ]
  \end{tikzcd}
\]

We will proceed using the initial $\SigFun{\Sigma}$-algebra $\alpha$, as
follows, by postcomposing it with a morphism $\beta$ from the environment into
the signature endofunctor, which interprets the syntax of operator applications:
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{
      {\SemBrackets{\Theta\triangleright\Upsilon\parallel\Gamma}}_{P}
    }}
      \arrow[r, "\IMode{\beta}"]
\&
    {\IMode{
      {\SigFun{\Sigma}(P)}_{\tau}
    }}
      \arrow[r, "\IMode{\alpha_\tau}"]
\&
    {\IMode{P_\tau}}
  \end{tikzcd}
\]

The construction of $\beta$ proceeds by renaming the parameters of the operator
$\vartheta$ and constructing the (bound) exponentiated arguments $\gamma$ of the
operator.
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , r
        , dashed
        , "
          \Define{
            \beta\,
          }{
            \,\Tuple{
              \SemBrackets{\vartheta}_P, \lambda\gamma
            }
          }
          "
      ]
\&[4.0em]
    {\IMode{
      \coprod_{
        \vartheta\in \Operators_{\MkArity{\vec{v}}{\tau}}
      }
      \prod_{
        \MkValence{\vec{\sigma}_i}{\vec{\tau}_i}{\tau_i}\in\vec{v}
      }
      P_{\tau_i}^{\Yoneda{\vec{\sigma}_i\parallel\vec{\tau}_i}}
    }}
  \end{tikzcd}
\]
Arguments $\lambda\IMode{{\gamma}_{i}}$ are the exponential transposes (curried
form) of the composites $\IMode{{\gamma}_{i}}$:
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , dashed
        , d
        , swap
        , "\OMode{\lambda{\gamma}_{i}}"
      ]
\&
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
      \times
      \Yoneda{
        \vec{\sigma}_{i}\parallel\vec{\tau}_{i}}
      }
    }
      \arrow[
        , r
        , "
          \IMode{
            \Tuple{
              {\pi}_{[1,1]},
              {\phi}_{i},
              {\psi}_{i}
            }
          }
          "
        ]
      \arrow[
        , dashed
        , d
        , swap
        , "\OMode{{\gamma}_{i}}"
      ]
\&[3.5em]
    {\IMode{
      \SemBrackets{
        \Theta\triangleright\Upsilon,
        \vec{\sigma}_i\parallel\Gamma,
        \vec{\tau}_{i}
      }_{P}
    }}
      \ar{dl}[
        , rotate = +19.25
        , xshift = -4.5em
        , yshift = -0.2em
      ]{\IMode{\SemBrackets{\Theta\triangleright\Upsilon,\vec{\sigma}_{i}\parallel\Gamma,\vec{\tau}_{i}\vdash M_i:\tau_i}_P}}
\\[2.0em]
    {\IMode{{P}_{{\tau}_{i}}^{\Yoneda{\vec{\sigma}_{i}\parallel\vec{\tau}_{i}}}}}
\&
    {\IMode{P_{{\tau}_{i}}}}
\&
  \end{tikzcd}
\]
where $\phi_i,\psi_i$ are defined as follows:
\begin{gather*}
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{
      {\SemBrackets{\Theta\triangleright\Upsilon\parallel\Gamma}}_{P}
      \times
      \Yoneda{\vec{\sigma}_i\parallel\vec{\tau}_i}
    }}
      \arrow[
        , r
        , dashed
        , "
          \Define
            {
              \phi_i\,
            }
            {
              \,
                \Tuple{\pi_u\circ\pi_1}_{u\in\Dom{\Upsilon}}
              ,
                \,\Tuple{\pi_u\circ\pi_{[2,1]}}_{u\in\Dom{\vec{\sigma}_i}}
            }
          "
      ]
\&[12.0em]
    {\IMode{\SymPsh^{\{\Upsilon,\vec{\sigma}_i\}}}}
\\[-1.0em]
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
      \times
      \Yoneda{\vec{\sigma}_i\parallel\vec{\tau}_i}
    }}
      \arrow[
        , r
        , dashed
        , "
          \Define{
            \psi_i\,
          }{
            \,
              \Tuple{\pi_x\circ\pi_1}_{x\in\Dom{\Gamma}}
            ,
              \,\Tuple{\pi_x\circ\pi_{[2,1]}}_{x\in\Dom{\vec{\tau}_i}}
          }
          "
      ]
\&[12.0em]
    {\IMode{\VarPsh^{[\Gamma,\vec{\tau}_i]}}}
  \end{tikzcd}
\end{gather*}

This concludes the interpretation of well-sorted terms into any $\Sigma$-model.

\section{Case Study: Wellformed Sequents}

The representation of telescopes and sequents in a logical framework is
notoriously difficult; whilst it is possible to use higher-order abstract
syntax or abts to encode the binding-structure of telescopes and sequents, the
encoding is sufficiently laborious and obscure that it is not used in practice.
Crary has demonstrated a first-order encoding of contexts in the logical
framework in bijection with actual LF-contexts~\cite{crary:2009}, which has
been successfully used in large-scale mechanization efforts, including that of
Standard ML~\cite{lee-crary-harper:2007} and the Edinburgh Logical Framework
itself~\cite{martens-crary:2012}.

We will approach the problem of encoding telescopes and sequents from the
\emph{refinements} perspective, where a conservative approximation of the
grammar is first given using the abt logical framework, and then the
correctness of a code is expressed separately in a judgment that refines the
existing specification.  Because we have not committed to using the built-in
binding machinery to express the well-scopedness of telescopes and sequents, we
are free to use \emph{symbols} in order to model the variables in the context.
This is in fact quite sensible if we are actually trying to faithfully
represent the syntax of telescopes and sequents, rather than replace them with
their counterparts on the meta-level.

The approach outlined above is actually quite similar to the standard practice
in the Abella proof assistant \cite{gacek:2008}; in Abella, in addition to the
canonical forms, each type is inhabited by an infinite collection of nominal
constants or symbols, which can be used in the syntax of contexts. In order to
specify where such symbols are allowed to occur, a wellformedness predicate (a
``scheme'') is separately defined. Our setting is similar in that we may also
use symbols to encode the syntax of contexts, except that here, we have better
control over their proliferation because, contrary to the state of
affairs in Abella, symbols are \emph{not} terms.

This insight leads the way to a simple abt signature for the theory of
telescopes and sequents.
%
\newcommand\SortTele{\mathtt{tele}}
\newcommand\SortJdg{\mathtt{jdg}}
\newcommand\SortProp{\mathtt{prop}}
\newcommand\SortExpr{\mathtt{exp}}
\newcommand\OpNil{\mathtt{nil}}
\newcommand\OpSnoc[1]{\mathtt{snoc}[#1]}
\newcommand\OpHyp[1]{\mathtt{hyp}[#1]}
\newcommand\OpSequent{\mathtt{sequent}}
% %
\[
  \begin{array}{lr}
    \IsSort{\SortTele}&\textit{telescopes}\\
    \IsSort{\SortExpr}&\textit{expressions}\\
    \IsSort{\SortProp}&\textit{propositions}\\
    \IsSort{\SortJdg}&\textit{judgments}\\\\
    \IsOperator{\Upsilon, u:\SortExpr}{\OpHyp{u}}{
      \MkArity{}{\SortExpr}
    }\\\\
    \IsOperator{\Upsilon}{\OpNil}{
      \MkArity{}{\SortTele}
    }\\
    \IsOperator{\Upsilon, u:\SortExpr}{\OpSnoc{u}}{
      \MkArity{
        \MkValence{}{}{\SortTele},
        \MkValence{}{}{\SortProp}
      }{\SortTele}
    }\\\\
    \IsOperator{\Upsilon}{\OpSequent}{
      \MkArity{
        \MkValence{}{}{\SortTele},
        \MkValence{}{}{\SortProp}
      }{\SortJdg}
    }
  \end{array}
\]

Suppose we have encoded a fragment of type theory as well:
\[
  \begin{array}{l}
    \IsOperator{\Upsilon}{\mathtt{P}}{
      \MkArity{}{\SortProp}
    }
\\
    \IsOperator{\Upsilon}{\mathtt{pred}}{
      \MkArity{
        \MkValence{}{}{\SortExp}
      }{\SortProp}
    }
\\
  \end{array}
\]

Terms written using the abstract syntax will be difficult to read, so let us
define some notation:
\begin{align*}
  \IMode{\diamond}
&
  \triangleq \OMode{\OpNil}
\\
  \IMode{H, u:P}
&
  \triangleq \OMode{
    \App{\OpSnoc{u}}{H, P}
  }
\\
  \IMode{H\gg A}
&
  \triangleq \OMode{
    \App{\OpSequent}{
      H, A
    }
  }
\\
  \IMode{`u}
&
  \triangleq \OMode{\OpHyp{u}}
\end{align*}

Now, we have the following well-formed sequent:
\[
  \IsAbt{\cdot}{
    u:\SortExp,
    v:\SortExp
  }{\cdot}{
    \diamond,u:\mathtt{P},v:\App{\mathtt{pred}}{`u}
    \gg
    \App{\mathtt{pred}}{`u}
  }{\SortJdg}
\]

\newcommand\OpNabla[1]{\nabla[#1]}

The above sequent has free symbols, but we can close over them by adding a form
of parametric higher-order judgment to our object language, indexed by a
collection of sorts $\vec{\sigma}$:
\[
  \IsOperator{\Upsilon}{\OpNabla{\vec{\sigma}}}{
    \MkArity{
      \MkValence{\vec{\sigma}}{}{\SortJdg}
    }{\SortJdg}
  }
\]

Then, we may write a closed sequent judgment as follows:
\[
  \IsAbt{\cdot}{\cdot}{\cdot}{
    \App{\OpNabla{\SortExp,\SortExp}}{
      \MkBTm{u,v}{}{
        \diamond,u:\mathtt{P},v:\App{\mathtt{pred}}{`u}
        \gg
        \App{\mathtt{pred}}{`u}
      }
    }
  }{\SortJdg}
\]

\subsection{Refinements for wellformedness}

Having specified an approximation of the grammar of telescopes and sequents in
the abt logical framework, we can proceed to define proper wellformedness via
\emph{inductive refinement}~\cite{harper:2016}. The basic idea is to introduce a
new form of (meta)-judgment $\IsWf{\Theta}{\Upsilon}{\Gamma}{M}{\tau}$ which
expresses the extrinsic wellformedness properties we wish to verify,
presupposing $\IsAbt{\Theta}{\Upsilon}{\Gamma}{M}{\tau}$. Additionally, we
introduce an analogous judgment on bound terms,
$\IsWf{\Theta}{\Upsilon}{\Gamma}{E}{v}$ presupposing
$\IsAbt{\Theta}{\Upsilon}{\Gamma}{E}{v}$, defined uniformly as follows:
\[
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}
    }
  }{
    \IsWf{\Theta}{\Upsilon,\vec{u}:\vec{\sigma}}{\Gamma,\vec{x}:\vec{\tau}}{M}{\tau}
  }
\]

Likewise, wellformedness for variables and metavariables is defined uniformly:
\begin{gather*}
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{x}{\tau}
  }{
  }
\qquad
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{\tau}
  }{
    \begin{array}{l}
      \Lookup{\Theta}{\MV{m}}{\MkValence{\vec{\sigma}}{\tau_0,\dots,\tau_n}{\tau}}
\\
      \HypJ{
        \IsWf{\Theta}{\Upsilon}{\Gamma}{M_i}{\tau_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }
\end{gather*}

\begin{remark}
  Note that the refinement for variables $x$ is not trivial, since it is only
  defined in case the presupposition $\IsAbt{\Theta}{\Upsilon}{\Gamma}{x}{\tau}$
  is satisfied.
\end{remark}

The remainder of the definition of refinement proceeds by induction on sorts and
operators. For the sake of this example, we will just stipulate that anything of
sort $\SortExp$ or $\SortProp$ is grammatical if its subterms are grammatical:

\[
  \infer[
    \text{for $\Member{\tau}{\MkSet{\SortExp,\SortProp}}$}
  ]{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{\tau}
  }{
    \begin{array}{l}
      \IsOperator{\Upsilon}{\vartheta}{
        \MkArity{
          v_0,\dots,v_n
        }{\tau}
      }
\\
      \HypJ{
        \IsWf{\Theta}{\Upsilon}{\Gamma}{E_i}{v_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }
\]

The refinements for parametric judgment and sequents simply delegate to their
subterms as well:
\begin{gather*}
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      \App{\OpNabla{\vec{\sigma}}}{
        \MkBTm{\vec{u}}{}{J}
      }
    }{\SortJdg}
  }{
    \IsWf{\Theta}{\Upsilon,\vec{u}:\vec{\sigma}}{\Gamma}{J}{\SortJdg}
  }
\\[6pt]
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      H\gg A
    }{\SortJdg}
  }{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{H}{\SortTele}
&
    \IsWf{\Theta}{\Upsilon}{\Gamma}{A}{\SortProp}
  }
\end{gather*}

The refinement for telescopes proceeds by induction:
\begin{gather*}
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{\diamond}{\SortTele}
  }{
  }
\qquad
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{H,u:A}{\SortTele}
  }{
    \begin{array}{l}
      \IsWf{\Theta}{\Upsilon\setminus\MkSet{u}}{\Gamma}{H}{\SortTele}
\\
      \IsWf{\Theta}{\Upsilon\setminus\MkSet{u}}{\Gamma}{A}{\SortProp}
    \end{array}
  }
\end{gather*}

\section*{Acknowledgements}

The first author wishes to thank Robert Harper for numerous conversations about
abstract binding trees and symbolic parameters, and Andy Pitts for his help in
understanding multi-sorted nominal sets and atomic sheaves.

\newpage
\appendix
\appendixpage

\section{Sheafhood on $\SCtxSite$}

\begin{thm}
  \label{thm:pullback-preservation}
  A presheaf $\Of{X}{\Sets^{\SCtx}}$ is a sheaf on $\SCtxSite$ just when it
  preserves pullbacks.
\end{thm}

\begin{proof}

  The proof is essentially the same as that of the analogous lemma for the
  Schanuel topos as presented in \cite[A.2.1.11.h]{johnstone:2002}, but we will
  give a slightly more detailed version here. The presheaf $X$ is a sheaf on the
  atomic site $\SCtxSite$ just when, for any renaming
  $\Of{\varrho}{C\inj D}$ and any $\Member{n}{X(D)}$ if
  $\IsEq{n\cdot \varrho_0}{n\cdot \varrho_1}$ for all diagrams
  \[
    \begin{tikzcd}[sep=large]
      \IMode{C} \arrow[r, hook, "\IMode{\varrho}"] &
      \IMode{D}
        \arrow[r, hook, shift left, "\IMode{\varrho_0}"]
        \arrow[r, hook, swap, shift right, "\IMode{\varrho_1}"]
      &
      \IMode{E}
    \end{tikzcd}
  \]
  such that $\IsEq{\varrho_0\circ\varrho}{\varrho_1\circ\varrho}$, then there
  exists a unique $\Member{m}{X(C)}$ such that $\IsEq{m\cdot\varrho}{n}$. In other
  words, the arrow $X(\varrho)$ is an equalizer, as in the following:
  \[
    \begin{tikzcd}[sep=large]
      \IMode{X(C)} \arrow[r, "\IMode{X(\varrho)}"] &
      \IMode{X(D)}
        \arrow[r, shift left, "\IMode{X(\varrho_0)}"]
        \arrow[r, swap, shift right, "\IMode{X(\varrho_1)}"]&
      \IMode{X(E)}
      \\
      \IMode{\mathbb{1}}
        \arrow[u, densely dotted, "\OMode{m}"]
        \arrow[ur, "\IMode{n}"]
    \end{tikzcd}
  \]

  Now, because $\Sets$ is a regular category, $X(\varrho)$ is an equalizer
  precisely when it is a monomorphism. Therefore, if we have assumed that $X$
  preserves pullbacks, in order to demonstrate that $X$ is a sheaf, it suffices
  to show that $X(\varrho)$ is monic. If $X$ preserves pullbacks, then it also
  preserves monomorphisms, because in any category with pullbacks, $\Of{f}{A\ra
  B}$ is monic just when the square
  \[
    \begin{tikzcd}[sep=large]
      \IMode{A}
        \arrow[r, "\IMode{\ArrId{A}}"]
        \arrow[d, "\IMode{\ArrId{A}}"] &
      \IMode{A} \arrow[d, "\IMode{f}"]\\
      \IMode{A} \arrow[r, "\IMode{f}"] &
      \IMode{B}
    \end{tikzcd}
  \]
  is a pullback \cite[p.\ 16]{mac-lane-moerdijk:1992}. Because $X$ preserves
  monomorphisms, and all arrows in $\SCtx$ are monic, then $X(\varrho)$ is
  monic. Hence, $X$ is a sheaf.

  Next, we must show that if $X$ is a sheaf, then it preserves pullbacks; we
  will loosely track the proof of Proposition~2.6.15 in \cite{biering:2004}.
  Fix the following diagram such that it is a pullback square in $\SCtx$:
  \[
    \begin{tikzcd}[sep=large]
      \IMode{C}
        \arrow[r, "\IMode{f_j}"]
        \arrow[d, "\IMode{f_i}"] &
      \IMode{C_j} \arrow[d, "\IMode{s_j}"]\\
      \IMode{C_i} \arrow[r, "\IMode{s_i}"] &
      \IMode{D}
    \end{tikzcd}
  \]

  Then it suffices to show that the following diagram is also pullback square
  in $\Sets$:
  \[
    \begin{tikzcd}[sep=large]
      \IMode{X(C)}
        \arrow[r, "\IMode{X(f_j)}"]
        \arrow[d, "\IMode{X(f_i)}"] &
      \IMode{X(C_j)} \arrow[d, "\IMode{X(s_j)}"]\\
      \IMode{X(C_i)} \arrow[r, "\IMode{X(s_i)}"] &
      \IMode{X(D)}
    \end{tikzcd}
  \]

  To prove that the above diagram is a pullback, it suffices to show that for
  any $\Member{m_i}{X(C_i)}$ and $\Member{m_j}{X(C_j)}$ such that
  $\IsEq{X(s_i)(m_i)}{X(s_j)(m_j)}$, we have a unique $\Member{m}{X(C)}$; the
  universal property of the pullback follows immediately from this.

  Consider the singleton cover on $C$ that contains $\Define{h}{s_i\circ
  f_i}=\OMode{s_j\circ f_j}$; a matching family $\phi$ for the cover
  $\MkSet{h}$ is a map that takes $h$ to an object in $X(D)$, and an
  amalgamation for $\phi$ consists in an object $\Member{m}{X(C)}$ such that
  $\IsEq{\phi(h)}{X(h)(m)}$. Now recall that $X$ is a sheaf on $\SCtxSite$ if
  and only if every matching family has a unique amalgamation; for the matching
  family $\Define{\phi(h)}{X(s_i)(m_i)}$, then, we must have a unique amalgamation
  $\Member{m}{X(C)}$ since $X$ is a sheaf. Therefore, $X$ preserves pullbacks.

\end{proof}


\ifdraft{}{
  \newpage
  % \nocite{*}
  \bibliographystyle{abbrv}
  \bibliography{refs}
}

\end{document}
