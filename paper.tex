\documentclass[11pt]{article}

\usepackage{notation/modes}
\usepackage{notation/judgments}
\usepackage{notation/abts}
\usepackage{notation/common}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{agda} % this should come after ams*
\usepackage{catchfilebetweentags}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifdraft}
\usepackage{ifthen}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{scalerel}
\usepackage{setspace}
\usepackage{stmaryrd}
\usepackage{supertabular}
\usepackage{tikz-cd}
\usepackage{tikzpfeile}
\usepackage{todonotes}
\usepackage{url}

\definecolor{dark-gray}{gray}{0.20}

% fonts
\usepackage{pxfonts}
\usepackage{eulervm}
\usepackage{bbold}
\usepackage[
  activate={true,nocompatibility},
  kerning=true,
  spacing=true,
  tracking=true
]{microtype}
\microtypecontext{spacing=nonfrench}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}
%% Euler doesn't have \varsigma and \varrho
\DeclareSymbolFont{greekletters}{OML}{cmr}{m}{it}
\DeclareMathSymbol{\varrho}{\mathalpha}{greekletters}{"25}
\DeclareMathSymbol{\varsigma}{\mathalpha}{greekletters}{"26}

\newcommand\HypCat{\mathbf{H}}
\newcommand\Supp[1]{\mathbf{supp}(#1)}
\newcommand\SupportsUnmoded[3]{#1 \blacktriangleright_{#2} #3}
\newcommand\Supports[3]{\SupportsUnmoded{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}}

\newcommand\CalcFV[2]{
  \FV{\IMode{#1}}\leadsto \OMode{#2}
}

\newcommand\CalcFS[2]{
  \FS{\IMode{#1}}\leadsto \OMode{#2}
}

\newcommand\SortExp{\mathtt{exp}}

\newcommand\IsWf[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}\in_{\mathbf{wf}}\IMode{#5}%
}

\newcommand\Sheaves[1]{\mathbf{Sh}\left(#1\right)}
\newcommand\Presheaves[1]{\mathbf{Psh}\left(#1\right)}
\newcommand\Sheafify[1]{#1^{\#}}
\newcommand\ConstPsh[1]{\Delta[#1]}
\newcommand\ConstSh[1]{\Delta^\#[#1]}
\newcommand\SCtxSite{\SymSets[\Sorts]}

\begin{document}

\title{Syntax and Semantics of Abstract Binding Trees}
\date{}
\author{Jon Sterling and Darin Morrison}
\maketitle

Abstract binding trees (abts) are a generalization of abstract syntax trees
where operators may express variable binding structure as part of their arities.
Originally formulated by Peter Aczel~\cite{aczel:1978}, unisorted abts have been
deployed successfully as the uniform syntactic framework for several
implementations of Constructive Type Theory, including
Nuprl~\cite{constable:1986}, MetaPRL~\cite{hickey:2003} and
JonPRL~\cite{jonprl:2015}.

In \emph{Practical Foundations for Programming Languages}~\cite{harper:2016},
Robert Harper develops the multi-sorted version of abstract binding trees and
proposes an extension to include families of operators indexed by
\emph{symbols}, which are, unlike variables, subject to only
distinctness-preserving renaming and not substitution; furthermore, symbols do
not appear in the syntax of abts, and are only introduced as parameters to
operators. This extension to support symbols is essential for a correct
treatment of programming languages with open sums (e.g. ML's \texttt{exn} type),
as well as assignable references.

In parallel, M.\ Fiore and his collaborators have developed the categorical
semantics for several variations of second-order algebraic
theories~\cite{fiore:1999, fiore:2005, fiore-hur:2010, fiore-mamoud:2010}; of
these, the simply sorted variants are equivalent to Harper's abstract binding
trees augmented with a notion of second-order variable (metavariable).

The contribution of this paper is the development of the syntax and semantics of
multi-sorted abts, an extension of second order universal algebra to support
symbol-indexed families of operators. Additionally, we have developed the
categorical semantics for abts formally in Constructive Type Theory using the
Agda proof assistant~\cite{norell:2007}.

\section{Preliminaries}

Fix a set $\Sorts$ of \emph{sorts}. We will say $\IsSort{\tau}$ when
$\Member{\tau}{\Sorts}$. A valence $\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}$
specifies an expression of sort $\tau$ which binds symbols in $\vec{\sigma}$ and
variables in $\vec{\tau}$.

\[
  \infer{
    \IsValence{
      \MkValence
        {\sigma_0,\dots,\sigma_m}
        {\tau_0,\dots,\tau_n}
        {\tau}
    }
  }{
    \IsSort{\tau}
&
    \HypJ{\IsSort{\sigma_i}}{\Leq{i}{m}}
&
    \HypJ{\IsSort{\tau_i}}{\Leq{i}{n}}
  }
\]

An arity $\MkArity{\vec{v}}{\tau}$ specifies an operator of sort $\tau$ with
arguments of valences $\vec{v}$. We will call the set of valences $\Valences$,
and the set of arities $\Arities$.

\[
  \infer{
    \IsArity{
      \MkArity
        {v_0,\ldots,v_n}
        {\tau}
    }
  }{
    \IsSort{\tau}
&
    \HypJ
      {\IsValence{v_i}}
      {\Leq{i}{n}}
  }
\]

\subsection{Symbols, contexts and their sheaves}

Let $\SymSets$ be the category of finite cardinals and their injective maps;
then the comma construction $\SCtx$, with $\Discrete{\Sorts}$
the discrete category on the set $\Sorts$, is the category of contexts of
symbols whose objects are finite sets of symbols $U$ and sort-assignments
\begin{tikzcd}[cramped]
  \IMode{U}\arrow[r, "\IMode{\mathfrak{s}}"] &\IMode{\Sorts}
\end{tikzcd}, and whose morphisms are
sort-preserving renamings; we will write $\Upsilon$ for a symbol context
$(U,\mathfrak{s})$.

Now, a covariant presheaf $X$ on $\SCtx$ is an intensional set which is subject
to renamings
\begin{tikzcd}[cramped]
  \IMode{\Upsilon}\arrow[r, hook, "\IMode{\varrho}"] & \IMode{\Upsilon'}
\end{tikzcd};
that is, each element $\Member{m}{X(\Upsilon)}$ can be mapped to a unique
element $\Member{m\varrho}{X(\Upsilon')}$.

\begin{definition}[Support]
  For a presheaf $\Of{X}{\Sets^\SCtx}$, when
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon}\arrow[r, hook, "\IMode{\varrho}"] & \IMode{\Upsilon'}
  \end{tikzcd},
  we say that $\Upsilon$ supports $\Member{m}{\Upsilon'}$ (written
  $\Supports{\Upsilon}{\varrho}{m}$) when, for all
  \begin{tikzcd}[cramped]
    \IMode{\Upsilon'}\arrow[r, hook, "\IMode{\varrho_1}{,} \IMode{\varrho_2}"] & \IMode{\Upsilon''}
  \end{tikzcd},
  if $\IsEq{\varrho_1\circ\varrho}{\varrho_2\circ\varrho}$ then $\IsEq{m\varrho_1}{m\varrho_2}$.
\end{definition}

Intuitively, when $\Upsilon$ supports $\Member{m}{X(\Upsilon')}$, we would
expect that we can work backward to a unique $\Of{m'}{\Upsilon}$ such that
$\IsEq{m'\varrho}{m}$; whilst this is not in general the case for presheaves
$X$, it is precisely the sheaf condition for covariant presheaves on $\SCtx$
under the atomic topology \cite[p.~126]{mac-lane-moerdijk:1992}. The sheaf
condition, then, ensures that the notion of support is well-behaved.

Let $\Supp{m}$ be the \emph{least support} of $\Member{m}{X(\Upsilon')}$:
\[
  \Define{\Supp{m}}{
    \bigcap_{
      \begin{tikzcd}[cramped, ampersand replacement = \&]
        \Upsilon\arrow[r, hook, "\varrho"] \& \Upsilon'
      \end{tikzcd}
    }
    \SupportsUnmoded{\Upsilon}{\varrho}{m}
  }
\]
Intuitively, $\Supp{m}$ is the exact symbol context that $m$ depends on.

Going forward, we will write $\SCtxSite$ for the Grothendieck site
$\Pair{\OpCat{\left(\SCtx\right)}}{A}$, where $A$ is the atomic coverage (sc.\
every non-empty family covers).

\begin{remark}
  The presentation we have given above is related both to the Schanuel topos
  and, equivalently, Pitts' category of nominal sets \cite{fiore-staton:2006}; we differ only in
  discussing sheaves on $\SCtxSite$, as
  opposed to sheaves on $\OpCat{\SymSets}$ (i.e.\ unisorted contexts).
\end{remark}

\subsubsection{Constructions on sheaves}

For any Grothendieck site $\Match{\mathfrak{S}}{\Pair{\mathcal{C}}{J}}$, the
inclusion $\Of{\iota}{\Sheaves{\mathfrak{S}}\ra\Presheaves{\mathcal{C}}}$ of
sheaves into presheaves has a left adjoint
$\IMode{\Sheafify{(-)}}\dashv\IMode{\iota}$, which takes any presheaf
$\Of{X}{\Presheaves{\mathcal{C}}}$ to a unique sheaf
$\Of{\Sheafify{X}}{\Sheaves{\mathfrak{S}}}$, called the \emph{sheafification}
of $X$.

Every category of sheaves on a site gives rise to a topos, which equips us with
a number of standard constructions, including (among other things) the disjoint
union of sheaves $X\oplus Y$, the product of sheaves $X\otimes Y$, and the terminal sheaf $\mathbb{1}$.

Returning to the site $\SCtxSite$, we will write $\mathbf{S}_\tau$ for the sheaf
of symbols of sort $\tau$, a subobject of the Yoneda embedding of the empty
symbol context, $\Yoneda{\cdot}$.

\subsection{Operators and signatures}

Fix a family of sheaves of operators
$\Member{\Operators_a}{\Sheaves{\SCtxSite}}$, indexed by arities
$\Member{a}{\Arities}$; for each $\Operators_a$, arrows in $\SCtx$ will lift to
renamings in operators' symbolic parameters. Together, $\Sorts$ and $\Operators$ are said to form a \emph{signature}
$\Define{\Sigma}{\Pair{\Sorts}{\Operators}}$.

We will write $\IsOperator{\Upsilon}{\vartheta}{a}$ in case
$\Member{\vartheta}{\Operators_a(\Upsilon)}$; note that this judgment enjoys
the structural properties of weakening and exchange via functoriality of
$\Operators$. An operator signature is defined by specifying, for each arity
$a$, the sheaf $\Operators_a$, whose ``elements'' are the operators of arity
$a$.


\paragraph{Examples}

For instance, consider a $\lambda$-calculus with a single sort, $\SortExp$; we
give its signature $\Sigma_{\lambda}$ by asserting the following about its
operators:
\begin{gather*}
  \IsOperator{\Upsilon}{\mathtt{lam}}{
    \MkArity{
      \MkValence{}{\SortExp}{\SortExp}
    }{\SortExp}
  }\\
  \IsOperator{\Upsilon}{\mathtt{fix}}{
    \MkArity{
      \MkValence{}{\SortExp}{\SortExp}
    }{\SortExp}
  }\\
  \IsOperator{\Upsilon}{\mathtt{ap}}{
    \MkArity{
      \MkValence{}{}{\SortExp},
      \MkValence{}{}{\SortExp}
    }{\SortExp}
  }
\end{gather*}

These rules correspond to the following definition of $\Operators$:
\begin{align*}
  \ADefine{
    \Operators_{
       \MkArity{
        \MkValence{}{\SortExp}{\SortExp}
      }{\SortExp}
    }
  }{
    \mathbb{1}\oplus\mathbb{1}
  }
  \\
  %
  \ADefine{
    \Operators_{
      \MkArity{
        \MkValence{}{}{\SortExp},
        \MkValence{}{}{\SortExp}
      }{\SortExp}
    }
  }{
    \mathbb{1}
  }
\end{align*}

So far, we have made no use of symbols and parameters; however, consider the
extension of the calculus with assignables (references):
%
\begin{gather*}
  \IsOperator{\Upsilon}{\mathtt{decl}}{
    \MkArity{
      \MkValence{}{}{\SortExp},
      \MkValence{\SortExp}{}{\SortExp}
    }{
      \SortExp
    }
  }
\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathtt{get}[u]}{
    \MkArity{}{\SortExp}
  }
\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathtt{set}[u]}{
    \MkArity{
      \MkValence{}{}{\SortExp}
    }{
      \SortExp
    }
  }
\end{gather*}

These rules correspond to the following family of sheaves:
\begin{align*}
  \ADefine{
    \Operators_{
      \MkArity{
        \MkValence{}{}{\SortExp},
        \MkValence{\SortExp}{}{\SortExp}
      }{
        \SortExp
      }
    }
  }{
    \mathbb{1}
  }\\
  \ADefine{
    \Operators_{
      \MkArity{}{\SortExp}
    }
  }{
    \mathbf{S}_\SortExp
  }\\
  \ADefine{
    \Operators_{
      \MkArity{
        \MkValence{}{}{\SortExp}
      }{
        \SortExp
      }
    }
  }{
    \mathbf{S}_\SortExp
  }
\end{align*}

Declaring a new assignable consists in providing an initial value, and an
expression binding a symbol (which shall represent the assignable in scope).
Note that the functoriality of $\Operators$ guarantees for any renaming
$\Of{\varrho}{\Upsilon\inj\Upsilon'}$, a family of lifted maps
$\Of{\Operators_a(\varrho)}{\Operators_a(\Upsilon)\inj\Operators_a(\Upsilon')}$
natural in $a$, such that
$\IsOperator{\Upsilon'}{\Operators_a(\varrho)(\vartheta)}{a}$ when
$\IsOperator{\Upsilon}{\vartheta}{a}$. In particular, the renaming
$\Upsilon,u\mapsto\Upsilon,v$ shall take $\mathtt{get}[u]$ to
$\mathtt{get}[v]$. Going forward, we will write $\vartheta\varrho$ for
$\Operators_a(\varrho)$.


\section{Contexts}

In general, we will have three kinds of context: symbolic (parameter) contexts,
variable contexts, and metavaraible contexts The symbol contexts have already
been defined via the comma construction $\SCtx$, but they also admit a
syntactic characterization,
\begin{gather*}
  \infer{
    \IsSymCtx{\cdot}
  }{
  }
\qquad
  \infer{
    \IsSymCtx{\Upsilon,u:\tau}
  }{
    \IsSymCtx{\Upsilon}
&
    \IsSort{\tau}
&
    \NotIn{u}{\Dom\Upsilon}
  }
\end{gather*}
%
Because, modulo notation, we have $\Member{\Upsilon}{\SCtx}$ just when
$\IsSymCtx{\Upsilon}$, we will use the syntactic view when it is convenient.

Contexts of variables are similar to contexts of symbols, except that they
admit \emph{any} renamings, not just the injective ones. As such, when
$\FinSets$ is the category of finite cardinals and all functions between them, the
comma construction $\Ctx$ is the category of variable contexts. As above, we
can give them an equivalent syntactic treatment:
\begin{gather*}
  \infer{
    \IsVarCtx{\cdot}
  }{
  }
\qquad
  \infer{
    \IsVarCtx{\Gamma,x:\tau}
  }{
    \IsVarCtx{\Gamma}
&
    \IsSort{\tau}
&
    \NotIn{x}{\Dom\Gamma}
  }
\end{gather*}

A metavariable context consists of bindings of \emph{valences} to
metavariables; let $\Define{\Valences}{\MkSet{v\mid \IsValenceUnmoded{v}}}$ be the set
of valences. Then, the category of metavariable contexts is the comma
construction $\MCtx$, which likewise admits an equivalent inductive definition:
\begin{gather*}
  \infer{
    \IsMetaCtx{\cdot}
  }{
  }
\qquad
  \infer{
    \IsMetaCtx{\Theta,\MV{m}:v}
  }{
    \IsMetaCtx{\Theta}
&
    \IsValence{v}
&
    \NotIn{\MV{m}}{\Dom\Theta}
  }
\end{gather*}



\section{Abstract Binding Trees}

Let the judgment $\IsAbt{\Theta}{\Upsilon}{\Gamma}{M}{\tau}$ presuppose
$\IsMetaCtx{\Theta}$, $\IsSymCtx\Upsilon$, $\IsVarCtx\Gamma$ and
$\IsSort{\tau}$, meaning that $M$ is an abstract binding tree of sort $s$, with
metavariables in $\Theta$, parameters in $\Upsilon$, and variables in $\Gamma$.
Let the judgment $\IsBTm{\Theta}{\Upsilon}{\Gamma}{E}{v}$ presuppose
$\IsValence{v}$. Then, the syntax of abstract binding trees is inductively
defined in four rules:

\begin{gather*}
  \infer[\textit{var}]{
    \IsAbt{\Theta}{\Upsilon}{\Gamma}{x}{\tau}
  }{
    \Lookup{\Gamma}{x}{\tau}
  }
\\[6pt]
  \infer[\textit{mvar}]{
    \IsAbt{\Theta}{\Upsilon}{\Gamma}{
      \MApp{\MV{m}}{u_0,\dots,u_m}{M_0,\dots,M_n}
    }{\tau}
  }{
    \begin{array}{l}
      \Lookup{\Theta}{\MV{m}}{
        \MkValence{
          \sigma_0,\dots,\sigma_m
        }{
          \tau_0,\dots,\tau_n
        }{\tau}
      }
\\
      \HypJ{
        \Lookup{\Upsilon}{u_i}{\sigma_i}
      }{\Leq{i}{m}}
\\
      \HypJ{
        \IsAbt{\Theta}{\Upsilon}{\Gamma}{M_i}{\tau_i}
      }{\Leq{i}{n}}
    \end{array}
  }
\\[6pt]
  \infer[\textit{app}]{
    \IsAbt{\Theta}{\Upsilon}{\Gamma}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{\tau}
  }{
    \begin{array}{l}
      \IsOperator{\Upsilon}{\vartheta}{
        \MkArity{v_1,\dots,v_n}{\tau}
      }
\\
      \HypJ{
        \IsBTm{\Theta}{\Upsilon}{\Gamma}{E_i}{v_i}
      }{\Leq{i}{n}}
    \end{array}
  }
\\[6pt]
  \infer[\textit{abs}]{
    \IsBTm{\Theta}{\Upsilon}{\Gamma}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}
    }
  }{
    \IsAbt{
      \Theta
    }{
      \Upsilon, \vec{u}:\vec{\sigma}
    }{
      \Gamma,\vec{x}:{\vec{\tau}}
    }{
      M
    }{\tau}
  }
\end{gather*}

Abts are identified up to $\alpha$-equivalence.

\subsection{Calculating free variables}

We can easily calculate the variables free in an expression by recursion on its
structure:

\begin{gather*}
  \infer[\textit{var}]{
    \CalcFV{x}{\MkSet{x}}
  }{
  }\\[6pt]
  %
  \infer[\textit{mvar}]{
    \CalcFV{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \bigcup_{i\leq n} \vec{x}_i
    }
  }{
    \HypJ{
      \CalcFV{M_i}{\vec{x}_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %
  \infer[\textit{app}]{
    \CalcFV{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \bigcup_{i\leq n} \vec{x}_i
    }
  }{
    \HypJ{
      \CalcFV{E_i}{\vec{x}_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %
  \infer[\textit{abs}]{
    \CalcFV{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \vec{x}\setminus\vec{y}
    }
  }{
    \CalcFV{M}{\vec{x}}
  }
\end{gather*}

Because this is a total relation, henceforth we will write $\FV{M}$ for
$\vec{x}$ when $\CalcFV{M}{x}$.

\subsection{Calculating free symbols}

Whereas the calculation of free variables pivoted on the \emph{var} rule, the
calculation of free symbols will pivot on the \emph{app} rule, because the only
place a symbol can be introduced is as a parameter to an operator.

\begin{gather*}
  \infer[\textit{var}]{
    \CalcFS{x}{\MkSet{}}
  }{
  }\\[6pt]
  %
  \infer[\textit{mvar}]{
    \CalcFS{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \bigcup_{i\leq n} \vec{u}_i
    }
  }{
    \HypJ{
      \CalcFS{M_i}{\vec{u}_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %
  \infer[\textit{app}]{
    \CalcFS{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \Dom{\Supp{\vartheta}} \cup \bigcup_{i\leq n} \vec{u}_i
    }
  }{
    \HypJ{
      \CalcFS{E_i}{\vec{u}_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %
  \infer[\textit{abs}]{
    \CalcFS{
      \MkBTm{\vec{v}}{\vec{x}}{M}
    }{
      \vec{u}\setminus\vec{v}
    }
  }{
    \CalcFS{M}{\vec{u}}
  }
\end{gather*}

Because this is a total relation, henceforth we will write $\FS{M}$ for
$\vec{u}$ when $\CalcFS{M}{u}$.


\subsection{Renaming of symbols}

The only place that symbols appear in our calculus is as parameters to operators
(unlike variables, symbols are not terms). Therefore, the functorial action of
the operator sheaf can be lifted into terms by recursion on their
structure, via a pair of judgments $\IsRenaming{\varrho}{M}{N}$ and
$\IsRenaming{\varrho}{E}{F}$, presupposing $\Of{\varrho}{\Upsilon\inj\Upsilon'}$,
and $\IsAbt{\Theta}{\Upsilon}{\Gamma}{M}{\tau}$ and
$\IsAbt{\Theta}{\Upsilon}{\Gamma}{E}{v}$ respectively:

\begin{gather*}
  \infer{
    \IsRenaming{\varrho}{x}{x}
  }{
  }
\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{v}}{N_0,\dots,N_n}
    }
  }{
    \Match{\varrho(\vec{u})}{\vec{v}}
&
    \HypJ{
      \IsRenaming{\varrho}{M_i}{N_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta\varrho}{F_0,\dots,F_n}
    }
  }{
    \HypJ{
      \IsRenaming{\varrho}{E_i}{F_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }
  }{
    \IsRenaming{\varrho\setminus\vec{u}}{M}{N}
  }
\end{gather*}

Above, the notation $\varrho\setminus\vec{u}$ means the omission of the
variables $\vec{u}$ from the renaming $\varrho$. Because terms are identified up
to $\alpha$-equivalence, the renaming judgment is functional in its input, and
so we are justified in writing $\Rename{\varrho}{M}$ for $N$ when
$\IsRenaming{\varrho}{M}{N}$.

\subsection{Substitution of variables}

Variable substitution in abts is defined inductively by a pair of judgments,
$\IsSubst{N}{x}{M}{M'}$ and $\IsSubst{N}{x}{E}{F}$:

\begin{gather*}
  \infer{
    \IsSubst{N}{x}{y}{N}
  }{
    \IsEq{x}{y}
  }
\qquad
  \infer{
    \IsSubst{N}{x}{y}{y}
  }{
    \IsApart{x}{y}
  }
\\[6pt]
  \infer{
    \IsSubst{N}{x}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{u}}{M'_0,\dots,M'_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{M_i}{M'_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer{
    \IsSubst{N}{x}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta}{F_0,\dots,F_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{E_i}{F_i}
    }{
      \Leq{i}{n}
    }
  }
\end{gather*}
\begin{gather*}
  \infer{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M'}
    }
  }{
    \NotIn{x}{\vec{y}}
&
    \IsApart{\vec{u}}{\FS{N}}
&
    \IsApart{\vec{y}}{\FV{N}}
&
    \IsSubst{N}{x}{M}{M'}
  }
\qquad
  \infer{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }
  }{
    \Member{x}{\vec{y}}
&
    \IsApart{\vec{u}}{\FS{N}}
&
    \IsApart{\vec{y}}{\FV{N}}
  }
\end{gather*}

Going forward, we will write $\Subst{N}{x}{M}$ for $M'$ when
$\IsSubst{N}{x}{M}{M'}$, and $\Subst{\vec{N}}{\vec{x}}{M}$ for the simultaneous
substitution of $\vec{N}$ for $\vec{x}$ in $M$.

\subsection{Substitution of metavariables}

Metavariables are substituted by bound terms; since a metavariable may only
appear in an application expression $\MApp{\MV{m}}{\cdots}{\cdots}$, we will
instantiate the bound term at the supplied parameters and arguments.
Substitution for metavariables is defined inductively by the judgments
$\IsSubst{E}{\MV{m}}{M}{N}$ and $\IsSubst{E}{\MV{m}}{F}{F'}$:

\begin{gather*}
  \infer{
    \IsSubst{E}{\MV{m}}{x}{x}
  }{
  }
\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \MApp{\MV{n}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{n}}{\vec{u}}{N_0,\dots,N_n}
    }
  }{
    \IsApart{\MV{m}}{\MV{n}}
&
    \HypJ{
      \IsSubst{E}{\MV{n}}{M_i}{N_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer{
    \IsSubst{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }{\MV{m}}{
      \MApp{\MV{n}}{\vec{v}}{\vec{M}}
    }{
      N''
    }
  }{
    \IsEq{\MV{m}}{\MV{n}}
&
    \IsSubst{\vec{M}}{\vec{x}}{N}{N'}
&
    \IsRenaming{\vec{u}\mapsto\vec{v}}{N'}{N''}
  }\\[6pt]
  %
  \infer{
    \IsSubst{E}{\MV{m}}{
      \App{\vartheta}{F_0,\dots,F_n}
    }{
      \App{\vartheta}{F'_0,\dots,F'_n}
    }
  }{
    \HypJ{
      \IsSubst{E}{\MV{m}}{F_i}{F'_i}
    }{
      \Leq{i}{n}
    }
  }
\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }
  }{
    \IsApart{\vec{u}}{\FS{E}}
&
    \IsApart{\vec{x}}{\FV{E}}
&
    \IsSubst{E}{\MV{m}}{M}{N}
  }
\end{gather*}

As usual, we will write $\Subst{E}{\MV{m}}{M}$ for $N$ when
$\IsSubst{E}{\MV{m}}{M}{N}$.

\section{Model Theory}

Let $\Define{\HypCat}{\OpCat{(\SCtx\times\Ctx)}}$; then we fix the functor
category $\widehat{\HypCat}^\Sorts$ as our semantic universe.

Let $\Define{V_\tau(\Upsilon\parallel\Gamma)}{\MkSet{x\in\Dom\Gamma\mid
    \Gamma(x)=\tau}}$ be called the presheaf of variables; additionally, we have
a presheaf of symbols
$\Define{S_\tau(\Upsilon\parallel\Gamma)}{\MkSet{u\in\Dom\Upsilon\mid
    \Upsilon(x)=\tau}}$. Lastly, we have the presheaf of operators with arity
$a$,
$\Define{\Operators_a(\Upsilon\parallel\Gamma)}{\Operators\Pair{\Upsilon}{a}}$

\subsection{Substitution monoidal structures}
\newcommand\SymPsh{\mathbf{S}}
\newcommand\VarPsh{\mathbf{V}}

For an object $\Of{P}{\widehat{\HypCat}^\Sorts}$, we will use the notation
$P^{[\Gamma]}$ to mean $\prod_{x\in\Dom\Gamma}P_{\Gamma(x)}$; likewise,
$\SymPsh^{\{\Upsilon\}}$ shall mean $\prod_{u\in\Dom\Upsilon}S_{\Upsilon(u)}$. For a
presheaf $\Of{A}{\widehat{\HypCat}}$ and a sort-indexed family of presheaves
$\Of{P}{\widehat{\HypCat}^\Sorts}$, we have an operation $A\bullet P$, defined
as a coend in the following way:
\[
  \Define{(A\bullet P)(\Upsilon\parallel\Gamma)}{
    \int^{(\Upsilon'\parallel\Delta)\in\HypCat}
      A(\Upsilon'\parallel\Delta)
      \times \SymPsh^{\{\Upsilon'\}}(\Upsilon\parallel\Gamma)
      \times P^{[\Delta]}(\Upsilon\parallel\Gamma)
  }
\]

Using this, we can define a tensor $P\odot Q$ for
$\Of{P,Q}{\widehat{\HypCat}^\Sorts}$ as follows:
\[
  \HypJ{
    \Define{{(P\odot Q)}_{\tau}}{
      P_\tau\bullet Q
    }
\quad
  }{
    \Member{\tau}{\Sorts}
  }
\]

Then, $V$ is the unit to this tensor. We will say that an object
$\Of{P}{\widehat{\HypCat}^\Sorts}$ is a $\Sigma$-monoid in case it is equipped
with the following natural transformations where $\nu$ embeds variables into $P$
and $\varsigma$ equips $P$ with an operation for simultaneous substitutions of
variables. Furthermore, $\nu$ and $\varsigma$ induce maps ${\nu}_{\Gamma}$ and
${\varsigma}^{\tau}_{\Upsilon\parallel\Gamma}$:
\begin{gather*}
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{V}} \arrow[r, "\IMode\nu"]
    \&
    {\IMode{P}}
    \&
    {\IMode{P\odot P}}
      \arrow[l, swap, "\IMode\varsigma"]
  \end{tikzcd}\\[6pt]
  %
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{{V}^{[\Gamma]}}}
      \arrow[r, "\IMode{{\nu}_{\Gamma}}"]
    \&
    {\IMode{{P}^{[\Gamma]}}}
  \end{tikzcd}
  \qquad
  \begin{tikzcd}[cramped, sep = large, ampersand replacement = \&]
    {\IMode{{P_\tau^{\Yoneda{\Upsilon\parallel\Gamma}}\times \SymPsh^{\{\Upsilon\}}\times P^{[\Gamma]}}}}
      \arrow[r, "\IMode{\varsigma^\tau_{\Upsilon\parallel\Gamma}}"]
    \&
    {\IMode{P_\tau}}
  \end{tikzcd}
\end{gather*}

\subsection{The signature endofunctor and its initial algebras}

For each signature $\Match{\Sigma}{\Pair{\Sorts}{\Operators}}$, we have an
endofunctor
$\Of{\SigFun{\Sigma}}{\widehat{\HypCat}^\Sorts\ra\widehat{\HypCat}^\Sorts}$,
which is defined as follows:
\begin{align*}
  \IMode{{\SigFun{\Sigma}(X)}_{\tau}}
&
    \triangleq
    \OMode{
      \coprod_{
        \vartheta\in \Operators_{\MkArity{\vec{v}}{\tau}}
      }
      \prod_{
        \MkValence
          {\vec{\sigma}}
          {\vec{\tau}}
          {\tau_i}
        \in\vec{v}
      }
      X_{\tau_i}^{\Yoneda{\vec{\sigma}\parallel\vec{\tau}}}
    }
\end{align*}

Then, a $\Sigma$-model is a $\Sigma$-monoid $P$ which is equipped with an
initial algebra $\Of{\alpha}{\SigFun{\Sigma}(P)\ra P}$, which shall interpret
applications of each operator.

\subsection{Interpretation of terms}

The metavariable, symbol and variable contexts are interpreted in a model $P$ as
an environment presheaf in the following way:
\[
  \Define{
    \SemBrackets{
      \Theta\triangleright\Upsilon\parallel\Gamma
    }_P
  }{
    \left(
      \prod_{
        (m:%
        \MkValence
          {\vec{\sigma}}
          {\vec{\tau}}
          {\tau})
        \in\Theta
      }{{P_{\tau}}^{\Yoneda{\vec{\sigma}\parallel\vec{\tau}}}}
    \right)
    \times
    \SymPsh^{\{\Upsilon\}}
    \times
    \VarPsh^{[\Gamma]}
  }
\]

Then, the interpretation of a term in a model $P$ is a map from its environment
to $P$:
\[
  \Of{
    \SemBrackets{
      \Theta\triangleright\Upsilon\parallel\Gamma\vdash M:\tau
    }_{P}
  }{
    \SemBrackets{
      \Theta\triangleright\Upsilon\parallel\Gamma
    }_{P}\ra {P}_{\tau}
  }
\]

Variables are interpreted by the map
${\SemBrackets{
  \Theta\triangleright\Upsilon\parallel\Gamma\vdash x:\tau
}}_{P}$ which
projects them from the environment and embeds them into the model. Metavariables
are resolved by the map
${\SemBrackets{
  \Theta\triangleright\Upsilon\parallel\Gamma\vdash\MApp{\MV{m}}{\vec{u}}{\vec{M}}
  : \tau
}}_{P}$ (where
$\Lookup{\Theta}{\MV{m}}{\MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}}$) which
projects their interpretation from the environment and instantiates it via
substitution:
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{P_\tau}}
\&[8.0em]
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , rr
        , dashed
        , "
          \OMode{
            {\SemBrackets{
              \Theta\triangleright\Upsilon\parallel\Gamma
              \vdash
              x:\tau
            }}_{P}
          }
          "
      ]
      \ar{drr}[
        , rotate = -16.5
        , xshift = +1.5em
        , yshift = -0.2em
        , swap
      ]{
        {\nu}_{\Gamma} {\pi}_{3}
      }
      \ar{dl}[
        , rotate = +11.5
        , xshift = -2.75em
      ]{
        \IMode{
          \Tuple{
            \pi_\MV{m}\,
            \pi_1,
            \phi\,
            \pi_2,
            \psi
          }
        }
      }
      \arrow[
        , l
        , dashed
        , swap
        , "
          \OMode{
            {\SemBrackets{
              \Theta\triangleright\Upsilon\parallel\Gamma
              \vdash
              \MApp{\MV{m}}{\vec{u}}{\vec{M}}: \tau
            }}_{P}
          }"
      ]
\&[-2.0em]
    \null
\&[+3.0em]
    {\IMode{P_\tau}}
\\
    {\IMode{
      {P}_{\tau}^{
        \Yoneda{\vec{\sigma}\parallel\vec{\tau}}
      }
      \times \SymPsh^{\{\vec{\sigma}\}}
      \times P^{[\vec{\tau}]}
    }}
      \arrow[
        , u
        , "
          \IMode{
            \varsigma^\tau_{\vec{\sigma}\parallel\vec{\tau}}
          }
          "
        ]
\&
    \null
\&
    \null
\&
    {\IMode{P^{[\Gamma]}}}
      \arrow[
        , u
        , swap
        , "{\pi}_{x}"
      ]
\\
    {\IMode{P^{[\vec{\tau}]}}}
\&
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , dashed
        , l
        , swap
        , "
          \Define{
            \psi\,
          }{
            \,\Tuple{
              {\SemBrackets{
                \Theta\triangleright\Upsilon\parallel\Gamma\vdash M:\tau
              }}_{P}
            }_{(M,\tau)\in (\vec{M},\vec{\tau})}
          }
          "]
\&
    {\IMode{\SymPsh^{\{\Upsilon\}}}}
      \arrow[
        , dashed
        , r
        , "\Define{\phi\,}{\,\Tuple{\pi_u}_{u\in\vec{u}}}"
      ]
\&
    {\IMode{\SymPsh^{\{\vec{\sigma}\}}}}
  \end{tikzcd}
\]

Interpretation of operator applications is the most complicated. Recall that,
unlike in standard treatments of universal algebra, our operators are indexed by
symbol collections; therefore, operators must pass through suitable renamings in
order to be used in the interpretation. Let us begin by constructing for each
operator $\IsOperator{\Upsilon}{\vartheta}{a}$ the morphism
$\SemBrackets{\vartheta}_P$ which shall rename the parameters of the operator
using the environment:
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&, sep = huge]
    |[alias = Src]|
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , r
        , swap
        , "\IMode{\pi_2}"
      ]
\&
    {\IMode{\SymPsh^{\{\Upsilon\}}}}
      \arrow[
        , r
        , swap
        , "\IMode{\Operators_a(\pi_{(-)})(\vartheta)}"
      ]
\&[1.5em]
    |[alias = Tgt]|
    {\IMode{\Operators_a}}
      \arrow[
        , from = Src
        , to = Tgt
        , bend left
        , dashed
        , "\OMode{\SemBrackets{\vartheta}_{P}}"
      ]
  \end{tikzcd}
\]

We will proceed using the initial $\SigFun{\Sigma}$-algebra $\alpha$, as
follows, by postcomposing it with a morphism $\beta$ from the environment into
the signature endofunctor, which interprets the syntax of operator applications:
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{
      {\SemBrackets{\Theta\triangleright\Upsilon\parallel\Gamma}}_{P}
    }}
      \arrow[r, "\IMode{\beta}"]
\&
    {\IMode{
      {\SigFun{\Sigma}(P)}_{\tau}
    }}
      \arrow[r, "\IMode{\alpha_\tau}"]
\&
    {\IMode{P_\tau}}
  \end{tikzcd}
\]

The construction of $\beta$ proceeds by renaming the parameters of the operator
$\vartheta$ and constructing the (bound) exponentiated arguments $\gamma$ of the
operator.
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , r
        , dashed
        , "
          \Define{
            \beta\,
          }{
            \,\Tuple{
              \SemBrackets{\vartheta}_P, \lambda\gamma
            }
          }
          "
      ]
\&[4.0em]
    {\IMode{
      \coprod_{
        \vartheta\in \Operators_{\MkArity{\vec{v}}{\tau}}
      }
      \prod_{
        \MkValence{\vec{\sigma}_i}{\vec{\tau}_i}{\tau_i}\in\vec{v}
      }
      P_{\tau_i}^{\Yoneda{\vec{\sigma}_i\parallel\vec{\tau}_i}}
    }}
  \end{tikzcd}
\]
Arguments $\lambda\IMode{{\gamma}_{i}}$ are the exponential transposes (curried
form) of the composites $\IMode{{\gamma}_{i}}$:
\[
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
    }}
      \arrow[
        , dashed
        , d
        , swap
        , "\OMode{\lambda{\gamma}_{i}}"
      ]
\&
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
      \times
      \Yoneda{
        \vec{\sigma}_{i}\parallel\vec{\tau}_{i}}
      }
    }
      \arrow[
        , r
        , "
          \IMode{
            \Tuple{
              {\pi}_{[1,1]},
              {\phi}_{i},
              {\psi}_{i}
            }
          }
          "
        ]
      \arrow[
        , dashed
        , d
        , swap
        , "\OMode{{\gamma}_{i}}"
      ]
\&[3.5em]
    {\IMode{
      \SemBrackets{
        \Theta\triangleright\Upsilon,
        \vec{\sigma}_i\parallel\Gamma,
        \vec{\tau}_{i}
      }_{P}
    }}
      \ar{dl}[
        , rotate = +19.25
        , xshift = -4.5em
        , yshift = -0.2em
      ]{\IMode{\SemBrackets{\Theta\triangleright\Upsilon,\vec{\sigma}_{i}\parallel\Gamma,\vec{\tau}_{i}\vdash M_i:\tau_i}_P}}
\\[2.0em]
    {\IMode{{P}_{{\tau}_{i}}^{\Yoneda{\vec{\sigma}_{i}\parallel\vec{\tau}_{i}}}}}
\&
    {\IMode{P_{{\tau}_{i}}}}
\&
  \end{tikzcd}
\]
where $\phi_i,\psi_i$ are defined as follows:
\begin{gather*}
  \begin{tikzcd}[cramped, ampersand replacement = \&]
    {\IMode{
      {\SemBrackets{\Theta\triangleright\Upsilon\parallel\Gamma}}_{P}
      \times
      \Yoneda{\vec{\sigma}_i\parallel\vec{\tau}_i}
    }}
      \arrow[
        , r
        , dashed
        , "
          \Define
            {
              \phi_i\,
            }
            {
              \,\Pair{
                \Tuple{\pi_u\circ\pi_1}_{u\in\Dom{\Upsilon}}
              }{
                \,\Tuple{\pi_u\circ\pi_{[2,1]}}_{u\in\Dom{\vec{\sigma}_i}}
              }
            }
          "
      ]
\&[12.0em]
    {\IMode{\SymPsh^{\{\Upsilon,\vec{\sigma}_i\}}}}
\\[-1.0em]
    {\IMode{
      {\SemBrackets{
        \Theta\triangleright\Upsilon\parallel\Gamma
      }}_{P}
      \times
      \Yoneda{\vec{\sigma}_i\parallel\vec{\tau}_i}
    }}
      \arrow[
        , r
        , dashed
        , "
          \Define{
            \psi_i\,
          }{
            \,\Pair{
              \Tuple{\pi_x\circ\pi_1}_{x\in\Dom{\Gamma}}
            }{
              \,\Tuple{\pi_x\circ\pi_{[2,1]}}_{x\in\Dom{\vec{\tau}_i}}
            }
          }
          "
      ]
\&[12.0em]
    {\IMode{\VarPsh^{[\Gamma,\vec{\tau}_i]}}}
  \end{tikzcd}
\end{gather*}

This concludes the interpretation of well-sorted terms into any $\Sigma$-model.

\section{Case Study: Wellformed Sequents}

The representation of telescopes and sequents in a logical framework is
notoriously difficult; whilst it is possible to use higher-order abstract syntax
or abts to encode the binding-structure of telescopes and sequents, the encoding
is sufficiently laborious and obscure that it is not used in practice.

Crary has demonstrated a first-order encoding of contexts in the logical
framework in bijection with actual LF-contexts~\cite{crary:2009}, which has been
successfully used in large-scale mechanization efforts, including that of
Standard ML~\cite{lee-crary-harper:2007} and the Edinburgh Logical Framework
itself~\cite{martens-crary:2012}.

\todo[inline]{talk about context encodings in Abella}

We will approach the problem of encoding telescopes and sequents from the
\emph{refinements} perspective, where a conservative approximation of the
grammar is first given using the abt logical framework, and then the correctness
of a code is expressed separately in a judgment that refines the existing
specification.

Because we have not committed to using the built-in binding machinery to express
the well-scopedness of telescopes and sequents, we are free to use
\emph{symbols} in order to model the variables in the context. This is in fact
quite sensible if we are actually trying to faithfully represent the syntax of
telescopes and sequents, rather than replace them with their counterparts on the
meta-level.

This insight leads the way to a simple abt signature for the theory of
telescopes and sequents.
%
\newcommand\SortTele{\mathtt{tele}}
\newcommand\SortJdg{\mathtt{jdg}}
\newcommand\SortType{\mathtt{type}}
\newcommand\SortExpr{\mathtt{exp}}
\newcommand\OpNil{\mathtt{nil}}
\newcommand\OpSnoc[1]{\mathtt{snoc}[#1]}
\newcommand\OpVar[1]{\mathtt{var}[#1]}
\newcommand\OpSequent{\mathtt{sequent}}
% %
\[
  \begin{array}{l}
    \IsSort{\SortTele}\\
    \IsSort{\SortExpr}\\
    \IsSort{\SortType}\\
    \IsSort{\SortJdg}\\\\
    \IsOperator{\Upsilon, u:\SortExpr}{\OpVar{u}}{
      \MkArity{}{\SortExpr}
    }\\\\
    \IsOperator{\Upsilon}{\OpNil}{
      \MkArity{}{\SortTele}
    }\\
    \IsOperator{\Upsilon, u:\SortExpr}{\OpSnoc{u}}{
      \MkArity{
        \MkValence{}{}{\SortTele},
        \MkValence{}{}{\SortType}
      }{\SortTele}
    }\\\\
    \IsOperator{\Upsilon}{\OpSequent}{
      \MkArity{
        \MkValence{}{}{\SortTele},
        \MkValence{}{}{\SortType}
      }{\SortJdg}
    }
  \end{array}
\]

\newcommand\OpPi{\mathtt{pi}}
\newcommand\OpSg{\mathtt{sg}}
\newcommand\OpBool{\mathtt{bool}}
\newcommand\OpSo{\mathtt{isTrue}}

Suppose we have encoded a fragment of type theory as well:
\[
  \begin{array}{l}
    \IsOperator{\Upsilon}{\top}{
      \MkArity{}{\SortType}
    }
\\
    \IsOperator{\Upsilon}{\bot}{
      \MkArity{}{\SortType}
    }
\\
    \IsOperator{\Upsilon}{\OpBool}{
      \MkArity{}{\SortType}
    }
\\
    \IsOperator{\Upsilon}{\OpSo}{
      \MkArity{
        \MkValence{}{}{\SortExp}
      }{\SortType}
    }
\\
    \IsOperator{\Upsilon}{\OpPi}{
      \MkArity{
        \MkValence{}{}{\SortType},
        \MkValence{}{\SortExp}{\SortType}
      }{\SortType}
    }
\\
    \IsOperator{\Upsilon}{\OpSg}{
      \MkArity{
        \MkValence{}{}{\SortType},
        \MkValence{}{\SortExp}{\SortType}
      }{\SortType}
    }
\\
  \end{array}
\]

Terms written using the abstract syntax will be difficult to read, so let us
define some notation:
\begin{align*}
  \IMode{\diamond}
&
  \triangleq \OMode{\OpNil}
\\
  \IMode{H, u:P}
&
  \triangleq \OMode{
    \App{\OpSnoc{u}}{H, P}
  }
\\
  \IMode{H\gg A}
&
  \triangleq \OMode{
    \App{\OpSequent}{
      H, A
    }
  }
\\
  \IMode{`u}
&
  \triangleq \OMode{\OpVar{u}}
\end{align*}

Now, we have the following well-formed sequent:
\[
  \IsAbt{\cdot}{
    u:\SortExp,
    v:\SortExp
  }{\cdot}{
    \diamond,u:\OpBool,v:\App{\OpSo}{`u}
    \gg
    \App{\OpSo}{`u}
  }{\SortJdg}
\]

\newcommand\OpNabla[1]{\nabla[#1]}

The above sequent has free symbols, but we can close over them by adding a form
of parametric higher-order judgment to our object language, indexed by a
collection of sorts $\vec{\sigma}$:
\[
  \IsOperator{\Upsilon}{\OpNabla{\vec{\sigma}}}{
    \MkArity{
      \MkValence{\vec{\sigma}}{}{\SortJdg}
    }{\SortJdg}
  }
\]

Then, we may write a closed sequent judgment as follows:
\[
  \IsAbt{\cdot}{\cdot}{\cdot}{
    \App{\OpNabla{\SortExp,\SortExp}}{
      \MkBTm{u,v}{}{
        \diamond,u:\OpBool,v:\App{\OpSo}{`u}
        \gg
        \App{\OpSo}{`u}
      }
    }
  }{\SortJdg}
\]

\subsection{Refinements for wellformedness}

Having specified an approximation of the grammar of telescopes and sequents in
the abt logical framework, we can proceed to define proper wellformedness via
\emph{inductive refinement}~\cite{harper:2016}. The basic idea is to introduce a
new form of (meta)-judgment $\IsWf{\Theta}{\Upsilon}{\Gamma}{M}{\tau}$ which
expresses the extrinsic wellformedness properties we wish to verify,
presupposing $\IsAbt{\Theta}{\Upsilon}{\Gamma}{M}{\tau}$. Additionally, we
introduce an analogous judgment on bound terms,
$\IsWf{\Theta}{\Upsilon}{\Gamma}{E}{v}$ presupposing
$\IsAbt{\Theta}{\Upsilon}{\Gamma}{E}{v}$, defined uniformly as follows:
\[
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkValence{\vec{\sigma}}{\vec{\tau}}{\tau}
    }
  }{
    \IsWf{\Theta}{\Upsilon,\vec{u}:\vec{\sigma}}{\Gamma,\vec{x}:\vec{\tau}}{M}{\tau}
  }
\]

Likewise, wellformedness for variables and metavariables is defined uniformly:
\begin{gather*}
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{x}{\tau}
  }{
  }
\qquad
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{\tau}
  }{
    \begin{array}{l}
      \Lookup{\Theta}{\MV{m}}{\MkValence{\vec{\sigma}}{\tau_0,\dots,\tau_n}{\tau}}
\\
      \HypJ{
        \IsWf{\Theta}{\Upsilon}{\Gamma}{M_i}{\tau_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }
\end{gather*}

\begin{remark}
  Note that the refinement for variables $x$ is not trivial, since it is only
  defined in case the presupposition $\IsAbt{\Theta}{\Upsilon}{\Gamma}{x}{\tau}$
  is satisfied.
\end{remark}

The remainder of the definition of refinement proceeds by induction on sorts and
operators. For the sake of this example, we will just stipulate that anything of
sort $\SortExp$ or $\SortType$ is grammatical if its subterms are grammatical:

\[
  \infer[
    \text{for $\Member{\tau}{\MkSet{\SortExp,\SortType}}$}
  ]{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{\tau}
  }{
    \begin{array}{l}
      \IsOperator{\Upsilon}{\vartheta}{
        \MkArity{
          v_0,\dots,v_n
        }{\tau}
      }
\\
      \HypJ{
        \IsWf{\Theta}{\Upsilon}{\Gamma}{E_i}{v_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }
\]

The refinements for parametric judgment and sequents simply delegate to their
subterms as well:
\begin{gather*}
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      \App{\OpNabla{\vec{\sigma}}}{
        \MkBTm{\vec{u}}{}{J}
      }
    }{\SortJdg}
  }{
    \IsWf{\Theta}{\Upsilon,\vec{u}:\vec{\sigma}}{\Gamma}{J}{\SortJdg}
  }
\\[6pt]
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{
      H\gg A
    }{\SortJdg}
  }{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{H}{\SortTele}
&
    \IsWf{\Theta}{\Upsilon}{\Gamma}{A}{\SortType}
  }
\end{gather*}

The refinement for telescopes proceeds by induction:
\begin{gather*}
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{\diamond}{\SortTele}
  }{
  }
\qquad
  \infer{
    \IsWf{\Theta}{\Upsilon}{\Gamma}{H,u:A}{\SortTele}
  }{
    \begin{array}{l}
      \IsWf{\Theta}{\Upsilon\setminus\MkSet{u}}{\Gamma}{H}{\SortTele}
\\
      \IsWf{\Theta}{\Upsilon\setminus\MkSet{u}}{\Gamma}{A}{\SortType}
    \end{array}
  }
\end{gather*}

\ifdraft{}{
  \nocite{*}
  \bibliographystyle{abbrv}
  \bibliography{refs}
}

\end{document}
