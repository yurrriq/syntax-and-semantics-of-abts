\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fontspec}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{scalerel}
\usepackage{setspace}
\usepackage{stmaryrd}
\usepackage{supertabular}
\usepackage{tikz-cd}
\usepackage{unicode-math}
\usepackage{url}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{xunicode}

\definecolor{dark-gray}{gray}{0.20}

% fonts
\usepackage[
  activate={true,nocompatibility},
  final,
  tracking=true
]{microtype}
\setmainfont{Linux Libertine O}
\setmathfont{Asana Math}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}

\def\IModeColorName{MidnightBlue}
\def\OModeColorName{Maroon}

\newcommand\IMode[1]{{\color{\IModeColorName}{#1}}}
\newcommand\OMode[1]{{\color{\OModeColorName}{#1}}}

\newcommand\HypJ[2]{#1\ \ (#2)}
\newcommand\GenJ[2]{\vert_{\IMode{#1}}\; #2}

\newcommand\IsTac[1]{\IMode{#1}\ \textit{tactic}}

\newcommand\MkSet[1]{\left\{#1\right\}}
\newcommand\Member[2]{\IMode{#1}\in\IMode{#2}}
\newcommand\EqMember[3]{\IMode{#1}=\IMode{#2}\in\IMode{#3}}
\newcommand\Of[2]{\IMode{#1} : \IMode{#2}}

\newcommand\MkValence[3]{%
  \ifthenelse{\equal{#1}{}}{}{%
    \{#1\}%
  }%
  \ifthenelse{\equal{#2}{}}{}{%
    [#2]%
  }.\, #3
}
\newcommand\MkBTm[3]{\{#1\}[#2].\, #3}
\newcommand\MkArity[2]{(#1)\, #2}
\newcommand\IsArity[1]{\IMode{#1}\ \textit{arity}}
\newcommand\IsValence[1]{\IMode{#1}\ \textit{valence}}
\newcommand\IsSort[1]{\IMode{#1}\ \textit{sort}}
\newcommand\Leq[2]{\IMode{#1}\leq\IMode{#2}}

\newcommand\ArrId[1]{1_{#1}}
\newcommand\Match[2]{\IMode{#1}\equiv\OMode{#2}}

\newcommand\Symbols{\mathbb{I}}
\newcommand\Finsets{\mathbb{F}}
\newcommand\Sorts{\mathcal{S}}
\newcommand\Valences{\mathcal{V}}
\newcommand\Arities{\mathcal{A}}
\newcommand\Operators{\mathcal{O}}

\newcommand\Cats{\mathbf{Cat}}
\newcommand\Discrete[1]{#1_{\equiv}}
\newcommand\Sets{\mathbf{Set}}
\newcommand\SCtx{\mathbf{SCtx}}

\newcommand\IsOperator[3]{\IMode{#1}\Vdash \IMode{#2} : \OMode{#3}}

\newcommand\IsMetaCtx[1]{\IMode{#1}\ \textit{mctx}}
\newcommand\IsVarCtx[1]{\IMode{#1}\ \textit{vctx}}
\newcommand\IsSymCtx[1]{\IMode{#1}\ \textit{sctx}}

\newcommand\Lookup[3]{\IMode{#1}\ni\IMode{#2}:\OMode{#3}}

\newcommand\Grothendieck[2]{\oint^{#1} #2#1}
\newcommand\Pair[2]{\langle #1, #2 \rangle}
\newcommand\FLift[2]{
  \Operators\langle#1%
  \ifthenelse{\equal{#2}{}}{}{, #2}\rangle
}
\newcommand\PairTimes[2]{\langle #1\, {\scriptstyle {{\times}}}\, #2 \rangle}
\newcommand\SSingleton{\bullet}
\newcommand\Forget[1]{|\, #1\, |}

\newcommand\Comma[2]{#1 \downarrow #2}
\newcommand\Coslice[2]{#1\, /\, #2}

\newcommand\IsAbt[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}:\OMode{#5}%
}
\newcommand\IsWf[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}\in_{\mathbf{wf}}\IMode{#5}%
}

\newcommand\IsBTm[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}:\IMode{#5}%
}

\newcommand\MV[1]{\textsc{#1}}
\newcommand\MApp[3]{#1\{#2\}(#3)}
\newcommand\App[2]{#1(#2)}
\newcommand\Dom[1]{\left\vert #1\right\vert}
\newcommand\FV[1]{\mathbf{FV}\left(#1\right)}
\newcommand\FS[1]{\mathbf{FS}\left(#1\right)}
\newcommand\NotIn[2]{\IMode{#1}\notin\IMode{#2}}
\newcommand\SortExp{\mathsf{exp}}

\newcommand\Hom[3]{#1\left[#2,#3\right]}

\newcommand\Rename[2]{
  #2\upharpoonright #1
}
\newcommand\IsRenaming[3]{
  \Rename{\IMode{#1}}{\IMode{#2}}%
  \leadsto\OMode{#3}%
}

\newcommand\Subst[3]{
  \left[#1\, /\, #2\right]#3%
}

\newcommand\IsSubst[4]{%
  \Subst{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}%
  \leadsto\OMode{#4}%
}


\newcommand\IsEq[2]{\IMode{#1} = \IMode{#2}}
\newcommand\IsApart[2]{\IMode{#1} \mathrel{\#} \IMode{#2}}

\newcommand\Define[2]{\IMode{#1}\triangleq\OMode{#2}}


\begin{document}

\title{Abstract Binding Trees}
\date{}
\author{Jon Sterling and Darin Morrison}
\maketitle

\section{Preliminaries}

Fix a set $\Sorts$ of \emph{sorts}. We will say $\IsSort{s}$ when
$\Member{s}{S}$. A valence $\MkValence{\vec{p}}{\vec{q}}{s}$ specifies an
expression of sort $s$ which binds symbols in $\vec{p}$ and variables in
$\vec{q}$.

\[
  \infer{
    \IsValence{\MkValence{p_0,\dots,p_m}{q_0,\dots,q_n}{s}}
  }{
    \IsSort{s} &
    \HypJ{\IsSort{p_i}}{\Leq{i}{m}} &
    \HypJ{\IsSort{q_i}}{\Leq{i}{n}} &
  }
\]

An arity $\MkArity{\vec{v}}{s}$ specifies an operator of sort $s$ with
arguments of valences $\vec{v}$. We will call the set of valences $\Valences$,
and the set of arities $\Arities$.

\[
  \infer{
    \IsArity{\MkArity{v_0,...,v_n}{s}}
  }{
    \IsSort{s} &
    \HypJ{\IsValence{v_i}}{\Leq{i}{n}}
  }
\]


Let $\Symbols$ be an infinite set of symbols. Let $\Finsets$ be the category of
finite subsets of $\Symbols$ and their injective maps; then the comma
construction $\Define{\SCtx}{\Comma{\Finsets}{\Discrete{\Sorts}}}$, with
$\Discrete{\Sorts}$ the discrete category on the set $\mathcal{S}$, is the
category of contexts of symbols, whose objects are finite sets of symbols $U$
and sort-assignments $\Of{\mathfrak{s}}{U\to\Sorts}$, and whose morphisms are
sort-preserving renamings; we will write $\Upsilon$ for a symbol context
$(U,\mathfrak{s})$.

Then, fix a covariant presheaf (copresheaf) of operators
$\Of{\Operators}{\SCtx\times\Discrete{\Arities}\to\Sets}$ such that the arrows
in $\SCtx$ lift to renamings of operators' parameters. Via the Grothendieck
construction\footnote{In this case, $\mathbf{C}\Grothendieck{}{\Psi}$
  represents the category of elements of a copresheaf
  $\Of{\Psi}{\mathbf{C}\to\Sets}$ but we keep the $\mathbf{C}$ implicit and
  simply refer to it as the Grothendieck construction.  Alternatively, this
  construction can be understood as a coend
$\IMode{\mathbf{C}\Grothendieck{}{\Psi}}\cong \IMode{\int^{c \in
\mathbf{C}}\Coslice{c}{\mathbf{C}} \otimes \Discrete{\Psi(c)}}$.}
$\Of{\Grothendieck{}{(-)}}{\Sets^{\mathbf{C}}\to\Cats}$ on operators, we have a
category of objects
$\Member{\Pair{\Pair{\Upsilon}{a}}{\vartheta}}{\Grothendieck{}{\Operators}}$
for $\Member{\vartheta}{\Operators\Pair{\Upsilon}{a}}$ and morphisms
$\Hom{\Grothendieck{}{\Operators}}{\Pair{\Pair{\Upsilon}{a}}{\vartheta}}{\Pair{\Pair{\Upsilon'}{a'}}{\vartheta'}}$
for $\Of{\Pair{\varrho}{f}}{\Pair{\Upsilon}{a}\to\Pair{\Upsilon'}{a'}}$ such
that
$\EqMember{\FLift{\varrho}{f}(\vartheta)}{\vartheta'}{\Operators\Pair{\Upsilon'}{a'}}$.
Equivalently, $\Grothendieck{}{\Operators}$ is the pullback of $\Operators$
along the universal $\Sets$-bundle where $\pi_{\Operators}$ is a discrete
Grothendieck opfibration and $\Forget{-}_{\SSingleton}$ is the forgetful functor
from pointed sets:

\[
\begin{tikzcd}[ampersand replacement = \&, sep = large]
  {\Grothendieck{}{\Operators}}
    \arrow[r, "{\pi_{\in}}"]
    \arrow[d, "{\pi_{\Operators}}" left]
  \& {\Sets_{\SSingleton}}
    \arrow[d, "{\Forget{-}_{\SSingleton}}"] \\
  {\SCtx\times\Discrete{\Arities}}
     \arrow[r, "{\Operators}" below]
  \& {\Sets} \\
\end{tikzcd}
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\vartheta}{a}
  }{
    \Member{\vartheta}{\Operators\langle\Upsilon,a\rangle}
  }
\]

The judgment $\IsOperator{\Upsilon}{\vartheta}{a}$ enjoys the structural
properties of weakening and exchange via the functoriality of
$\Operators$.

\paragraph{Examples}

Operators are defined by specifying the fibers of $\pi_{\Operators}$ in which
they reside. For instance, consider the lambda calculus with a single sort,
$\SortExp$; we give its signature by asserting the following about its
operators:
\begin{gather*}
  \IsOperator{\Upsilon}{\lambda}{
    \MkArity{\MkValence{}{\SortExp}{\SortExp}}{\SortExp}
  }\\
  \IsOperator{\Upsilon}{\mathsf{ap}}{
    \MkArity{
      \MkValence{}{}{\SortExp},
      \MkValence{}{}{\SortExp}
    }{\SortExp}
  }
\end{gather*}

So far, we have made no use of symbols and parameters; however, consider the
extension of the calculus with assignables (references):

\begin{gather*}
  \IsOperator{\Upsilon}{\mathsf{decl}}{
    \MkArity{
      \MkValence{}{}{\SortExp},
      \MkValence{\SortExp}{}{\SortExp}
    }{
      \SortExp
    }
  }\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathsf{get}[u]}{
    \MkArity{}{\SortExp}
  }\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathsf{set}[u]}{
    \MkArity{
      \MkValence{}{}{\SortExp}
    }{
      \SortExp
    }
  }
\end{gather*}

Declaring a new assignable consists in providing an initial value, and an
expression binding a symbol (which shall represent the assignable in scope).
Note that the functoriality of $\Operators$ guarantees for any renaming
$\Of{\varrho}{\Upsilon\to\Upsilon'}$ and $\Of{f}{a\to a'}$, a lifted map
$\Of{\FLift{\varrho}{f}}{\Operators\Pair{\Upsilon}{a}\to\Operators\Pair{\Upsilon'}{a'}}$
such that $\IsOperator{\Upsilon'}{\FLift{\varrho}{f}(\vartheta)}{a'}$ when
$\IsOperator{\Upsilon}{\vartheta}{a}$. Because the category
$\Discrete{\Arities}$ is discrete and has only identity arrows, through an abuse
of notation we will often write $\FLift{\varrho}{}$ to mean
$\FLift{\varrho}{\ArrId{}}$. In particular, the renaming
$\Upsilon,u\mapsto\Upsilon,v$ shall take $\mathsf{get}[u]$ to $\mathsf{get}[v]$.

\section{Contexts}

In general, we will have three kinds of context: metavariable contexts,
variable contexts, and symbol (parameter) contexts. A metavariable context
$\Omega$ consists of bindings of valences to metavariables; a variable context
$\Gamma$ is a collection of bindings of sorts to variables, and a parameter
context $\Upsilon$ is a collection of bindings of sorts to symbols.

\begin{gather*}
  \infer{
    \IsMetaCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsMetaCtx{\Omega,\MV{m}:v}
  }{
    \IsMetaCtx{\Omega} &
    \IsValence{v} &
    \NotIn{\MV{m}}{\Dom\Omega}
  }
\end{gather*}

\begin{gather*}
  \infer{
    \IsVarCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsVarCtx{\Gamma,x:s}
  }{
    \IsVarCtx{\Gamma} &
    \IsSort{s} &
    \NotIn{x}{\Dom\Gamma}
  }
\end{gather*}

\begin{gather*}
  \infer{
    \IsSymCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsSymCtx{\Upsilon,u:s}
  }{
    \IsVarCtx{\Upsilon} &
    \IsSort{s} &
    \NotIn{u}{\Dom\Upsilon}
  }
\end{gather*}

\section{Abstract Binding Trees}

Let the judgment $\IsAbt{\Omega}{\Upsilon}{\Gamma}{M}{s}$ presuppose
$\IsMetaCtx{\Omega}$, $\IsSymCtx\Upsilon$, $\IsVarCtx\Gamma$ and $\IsSort{s}$,
meaning that $M$ is an abstract binding tree of sort $s$, with metavariables in
$\Omega$, parameters in $\Upsilon$, and variables in $\Gamma$. Let the judgment
$\IsBTm{\Omega}{\Upsilon}{\Gamma}{E}{v}$ presuppose $\IsValence{v}$.  Then, the
syntax of abstract binding trees (abts) is inductively defined in four rules:

\begin{gather*}
  \infer[\textit{var}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{x}{s}
  }{
    \Lookup{\Gamma}{x}{s}
  }\\[6pt]
  %
  \infer[\textit{mvar}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{
      \MApp{\MV{m}}{u_0,\dots,u_m}{M_0,\dots,M_n}
    }{s}
  }{
    \begin{array}{l}
      \Lookup{\Omega}{\MV{m}}{\MkValence{p_0,\dots,p_m}{q_0,\dots,q_n}{s}}\\
      \HypJ{\Lookup{\Upsilon}{u_i}{p_i}}{\Leq{i}{m}}\\
      \HypJ{
        \IsAbt{\Omega}{\Upsilon}{\Gamma}{M_i}{q_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }\\[6pt]
  %
  \infer[\textit{app}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{s}
  }{
    \begin{array}{l}
      \IsOperator{\Upsilon}{\vartheta}{
        v_1,\dots,v_n
      }\\
      \HypJ{
        \IsBTm{\Omega}{\Upsilon}{\Gamma}{E_i}{q_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }\\[6pt]
  \infer[\textit{abs}]{
    \IsBTm{\Omega}{\Upsilon}{\Gamma}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkValence{\vec{p}}{\vec{q}}{s}
    }
  }{
    \IsAbt{\Omega}{\Upsilon, \vec{u}:\vec{p}}{\Gamma,\vec{x}:{\vec{q}}}{
      M
    }{
      s
    }
  }
\end{gather*}

Abts are identified up to $\alpha$-equivalence. Let $\FS{M}$ be the collection
of symbols free in $M$, and let $\FV{M}$ be the collection of variables free in
$M$. %% TODO: actually define these

\subsection{Renaming of Symbols}

The only place that symbols appear in our calculus is as parameters to
operators (unlike variables, symbols are not terms). Therefore, the functorial
action of the operator presheaf can be lifted into terms by recursion on their
structure, via a pair of judgments $\IsRenaming{\varrho}{M}{N}$ and
$\IsRenaming{\varrho}{E}{F}$, presupposing
$\Of{\varrho}{\Upsilon\to\Upsilon'}$, and $\IsAbt{\Omega}{\Upsilon}{\Gamma}{M}{s}$
and $\IsAbt{\Omega}{\Upsilon}{\Gamma}{E}{v}$ respectively:

\begin{gather*}
  \infer{
    \IsRenaming{\varrho}{x}{x}
  }{
  }\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{v}}{N_0,\dots,N_n}
    }
  }{
    \Match{\varrho(\vec{u})}{\vec{v}} &
    \HypJ{
      \IsRenaming{\varrho}{M_i}{N_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta'}{F_0,\dots,F_n}
    }
  }{
    \Match{\FLift{\varrho}{}(\vartheta)}{\vartheta'} &
    \HypJ{
      \IsRenaming{\varrho}{E_i}{F_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }
  }{
    \IsRenaming{\varrho\setminus\vec{u}}{M}{N}
  }
\end{gather*}

Above, the notation $\varrho\setminus\vec{u}$ means the omission of the
variables $\vec{u}$ from the renaming $\varrho$. Because terms are identified
up to $\alpha$-equivalence, the renaming judgment is functional in its input,
and so we are justified in writing $\Rename{\varrho}{M}$ for $N$ when
$\IsRenaming{\varrho}{M}{N}$.

%%% TODO: show that renaming preserves wellformedness

\subsection{Substitution of Variables}

Variable substitution in abts is defined inductively by a
pair of judgments, $\IsSubst{N}{x}{M}{M'}$ and $\IsSubst{N}{x}{E}{F}$:

\begin{gather*}
  \infer{
    \IsSubst{N}{x}{y}{N}
  }{
    \IsEq{x}{y}
  }\qquad
  \infer{
    \IsSubst{N}{x}{y}{y}
  }{
    \IsApart{x}{y}
  }\\[6pt]
  \infer{
    \IsSubst{N}{x}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{u}}{M'_0,\dots,M'_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{M_i}{M'_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsSubst{N}{x}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta}{F_0,\dots,F_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{E_i}{F_i}
    }{
      \Leq{i}{n}
    }
  }
\end{gather*}
\begin{gather*}
  \infer{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M'}
    }
  }{
    \NotIn{x}{\vec{y}} &
    \IsApart{\vec{u}}{\FS{N}} &
    \IsApart{\vec{y}}{\FV{N}} &
    \IsSubst{N}{x}{M}{M'}
  }\qquad
  \infer{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }
  }{
    \Member{x}{\vec{y}} &
    \IsApart{\vec{u}}{\FS{N}} &
    \IsApart{\vec{y}}{\FV{N}}
  }
\end{gather*}

Going forward, we will write $\Subst{N}{x}{M}$ for $M'$ when
$\IsSubst{N}{x}{M}{M'}$, and $\Subst{\vec{N}}{\vec{x}}{M}$ for the
simultaneous substitution of $\vec{N}$ for $\vec{x}$ in $M$.

\subsection{Substitution of Metavariables}

Metavariables are substituted by bound terms; since a metavariable may only
appear in an application expression $\MApp{\MV{m}}{\cdots}{\cdots}$, we will
instantiate the bound term at the supplied parameters and arguments.
Substitution for metavariables is defined inductively by the judgments
$\IsSubst{E}{\MV{m}}{M}{N}$ and $\IsSubst{E}{\MV{m}}{F}{F'}$:

\begin{gather*}
  \infer{
    \IsSubst{E}{\MV{m}}{x}{x}
  }{
  }\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \MApp{\MV{n}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{n}}{\vec{u}}{N_0,\dots,N_n}
    }
  }{
    \IsApart{\MV{m}}{\MV{n}} &
    \HypJ{
      \IsSubst{E}{\MV{n}}{M_i}{N_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsSubst{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }{\MV{m}}{
      \MApp{\MV{n}}{\vec{v}}{\vec{M}}
    }{
      N''
    }
  }{
    \IsEq{\MV{m}}{\MV{n}} &
    \IsSubst{\vec{M}}{\vec{x}}{N}{N'} &
    \IsRenaming{\MkSet{\vec{u}\mapsto\vec{v}}}{N'}{N''}
  }\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \App{\vartheta}{F_0,\dots,F_n}
    }{
      \App{\vartheta}{F'_0,\dots,F'_n}
    }
  }{
    \HypJ{
      \IsSubst{E}{\MV{m}}{F_i}{F'_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }
  }{
    \IsApart{\vec{u}}{\FS{E}} &
    \IsApart{\vec{x}}{\FV{E}} &
    \IsSubst{E}{\MV{m}}{M}{N}
  }
\end{gather*}

As usual, we will write $\Subst{E}{\MV{m}}{M}$ for $N$ when
$\IsSubst{E}{\MV{m}}{M}{N}$.

\section{Case Study: Wellformed Sequents}

The representation of telescopes and sequents in a logical framework is
notoriously difficult; whilst it is possible to use higher-order abstract
syntax or abts to encode the binding-structure of telescopes
and sequents, the encoding is sufficiently laborious and obscure that it is not
used in practice.

Crary has demonstrated a first-order encoding of contexts in the logical
framework in bijection with actual LF-contexts \cite{crary:2009}, which has
been successfully used in large-scale mechanization efforts, including that of
Standard ML \cite{lee-crary-harper:2007} and the Edinburgh Logical Framework
itself \cite{martens-crary:2012}.

%%% TODO: talk about context encodings in Abella

We will approach the problem of encoding telescopes and sequents from the
\emph{refinements} perspective, where a conservative approximation of the
grammar is first given using the abt logical framework, and then the
correctness of a code is expressed separately in a judgment that refines the
existing specification.

Because we have not committed to using the built-in binding machinery to
express the well-scopedness of telescopes and sequents, we are free to use
\emph{symbols} in order to model the variables in the context. This is in fact
quite sensible if we are actually trying to faithfully represent the syntax of
telescopes and sequents, rather than replace them with their counterparts on
the meta-level.

This insight leads the way to a simple abt signature for the theory of telescopes
and sequents.
%
\newcommand\SortTele{\mathsf{tele}}
\newcommand\SortJdg{\mathsf{jdg}}
\newcommand\SortType{\mathsf{type}}
\newcommand\SortExpr{\mathsf{exp}}
\newcommand\OpNil{\mathsf{nil}}
\newcommand\OpSnoc[1]{\mathsf{snoc}[#1]}
\newcommand\OpVar[1]{\mathsf{var}[#1]}
\newcommand\OpSequent{\mathsf{sequent}}
%
\[
  \begin{array}{l}
    \IsSort{\SortTele}\\
    \IsSort{\SortExpr}\\
    \IsSort{\SortType}\\
    \IsSort{\SortJdg}\\\\
    \IsOperator{\Upsilon, u:\SortExpr}{\OpVar{u}}{
      \MkArity{}{\SortExpr}
    }\\\\
    \IsOperator{\Upsilon}{\OpNil}{
      \MkArity{}{\SortTele}
    }\\
    \IsOperator{\Upsilon, u:\SortExpr}{\OpSnoc{u}}{
      \MkArity{
        \MkValence{}{}{\SortTele},
        \MkValence{}{}{\SortType}
      }{\SortTele}
    }\\\\
    \IsOperator{\Upsilon}{\OpSequent}{
      \MkArity{
        \MkValence{}{}{\SortTele},
        \MkValence{}{}{\SortType}
      }{\SortJdg}
    }
  \end{array}
\]

\newcommand\OpPi{\mathsf{pi}}
\newcommand\OpSg{\mathsf{sg}}
\newcommand\OpBool{\mathsf{bool}}
\newcommand\OpSo{\mathsf{isTrue}}

Suppose we have encoded a fragment of type theory as well:
\[
  \begin{array}{l}
    \IsOperator{\Upsilon}{\top}{
      \MkArity{}{\SortType}
    }\\
    \IsOperator{\Upsilon}{\bot}{
      \MkArity{}{\SortType}
    }\\
    \IsOperator{\Upsilon}{\OpBool}{
      \MkArity{}{\SortType}
    }\\
    \IsOperator{\Upsilon}{\OpSo}{
      \MkArity{
        \MkValence{}{}{\SortExp}
      }{\SortType}
    }\\
    \IsOperator{\Upsilon}{\OpPi}{
      \MkArity{
        \MkValence{}{}{\SortType},
        \MkValence{}{\SortExp}{\SortType}
      }{\SortType}
    }\\
    \IsOperator{\Upsilon}{\OpSg}{
      \MkArity{
        \MkValence{}{}{\SortType},
        \MkValence{}{\SortExp}{\SortType}
      }{\SortType}
    }\\
  \end{array}
\]

Terms written using the abstract syntax will be difficult to read, so let us
define some notation:
\begin{align*}
  \IMode{\diamond} &\triangleq \OMode{\OpNil}\\
  \IMode{H, u:P} &\triangleq \OMode{
    \App{\OpSnoc{u}}{H, P}
  }\\
  \IMode{H\gg A} &\triangleq \OMode{
    \App{\OpSequent}{
      H, A
    }
  }\\
  \IMode{`u} &\triangleq \OMode{\OpVar{u}}
\end{align*}

Now, we have the following well-formed sequent:
\[
  \IsAbt{\cdot}{
    u:\SortExp,
    v:\SortExp
  }{\cdot}{
    \diamond,u:\OpBool,v:\App{\OpSo}{`u}%
    \gg%
    \App{\OpSo}{`u}
  }{\SortJdg}
\]

\newcommand\OpNabla[1]{\nabla[#1]}

The above sequent has free symbols, but we can close over them by adding a form
of parametric higher-order judgment to our object language, indexed by a
collection of sorts $\vec{s}$:
\[
  \IsOperator{\Upsilon}{\OpNabla{\vec{s}}}{
    \MkArity{
      \MkValence{\vec{s}}{}{\SortJdg}
    }{\SortJdg}
  }
\]

Then, we may write a closed sequent judgment as follows:
\[
  \IsAbt{\cdot}{\cdot}{\cdot}{
    \App{\OpNabla{\SortExp,\SortExp}}{
      \MkBTm{u,v}{}{
        \diamond,u:\OpBool,v:\App{\OpSo}{`u}%
        \gg%
        \App{\OpSo}{`u}
      }
    }
  }{\SortJdg}
\]

\subsection{Refinements for wellformedness}

Having specified an approximation of the grammar of telescopes and sequents in
the abt logical framework, we can proceed to define proper wellformedness via
\emph{inductive refinement}. The basic idea is to introduce a new form of
(meta)-judgment $\IsWf{\Omega}{\Upsilon}{\Gamma}{M}{s}$ which expresses the
extrinsic wellformedness properties we wish to verify, presupposing
$\IsAbt{\Omega}{\Upsilon}{\Gamma}{M}{s}$. Additionally, we introduce an
analogous judgment on bound terms, $\IsWf{\Omega}{\Upsilon}{\Gamma}{E}{v}$
presupposing $\IsAbt{\Omega}{\Upsilon}{\Gamma}{E}{v}$, defined uniformly as
follows:
\[
  \infer{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkValence{\vec{p}}{\vec{q}}{s}
    }
  }{
    \IsWf{\Omega}{\Upsilon,\vec{u}:\vec{p}}{\Gamma,\vec{x}:\vec{q}}{M}{s}
  }
\]

Likewise, wellformedness for variables and metavariables is defined uniformly:
\begin{gather*}
  \infer{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{x}{s}
  }{
  }\qquad
  \infer{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{s}
  }{
    \begin{array}{l}
      \Lookup{\Omega}{\MV{m}}{\MkValence{\vec{p}}{q_0,\dots,q_n}{s}}\\
      \HypJ{
        \IsWf{\Omega}{\Upsilon}{\Gamma}{M_i}{q_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }
\end{gather*}

\begin{remark}
  Note that the refinement for variables $x$ is not trivial, since it is only
  defined in case the presupposition $\IsAbt{\Omega}{\Upsilon}{\Gamma}{x}{s}$
  is satisfied.
\end{remark}

The remainder of the definition of refinement proceeds by induction on sorts
and operators. For the sake of this example, we will just stipulate that
anything of sort $\SortExp$ or $\SortType$ is grammatical if its subterms are
grammatical:

\[
  \infer[
    \text{for $\Member{s}{\MkSet{\SortExp,\SortType}}$}
  ]{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{s}
  }{
    \begin{array}{l}
      \IsOperator{\Upsilon}{\vartheta}{
        \MkArity{
          v_0,\dots,v_n
        }{s}
      }\\
      \HypJ{
        \IsWf{\Omega}{\Upsilon}{\Gamma}{E_i}{v_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }
\]

The refinements for parametric judgment and sequents simply delegate to their
subterms as well:
\begin{gather*}
  \infer{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{
      \App{\OpNabla{\vec{s}}}{
        \MkBTm{\vec{u}}{}{J}
      }
    }{\SortJdg}
  }{
    \IsWf{\Omega}{\Upsilon,\vec{u}:\vec{s}}{\Gamma}{J}{\SortJdg}
  }\\[6pt]
  \infer{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{
      H\gg A
    }{\SortJdg}
  }{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{H}{\SortTele} &
    \IsWf{\Omega}{\Upsilon}{\Gamma}{A}{\SortType}
  }
\end{gather*}

The refinement for telescopes proceeds by induction:
\begin{gather*}
  \infer{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{\diamond}{\SortTele}
  }{
  }
  \qquad
  \infer{
    \IsWf{\Omega}{\Upsilon}{\Gamma}{H,u:A}{\SortTele}
  }{
    \begin{array}{l}
      \IsWf{\Omega}{\Upsilon\setminus\MkSet{u}}{\Gamma}{H}{\SortTele}\\
      \IsWf{\Omega}{\Upsilon\setminus\MkSet{u}}{\Gamma}{A}{\SortType}
    \end{array}
  }
\end{gather*}

\nocite{*}
\bibliographystyle{abbrv}
\bibliography{refs}

\end{document}
