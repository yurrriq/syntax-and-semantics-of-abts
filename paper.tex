\documentclass[11pt]{article}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{amsmath, amsthm, stmaryrd, scalerel, amssymb}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{geometry}
\usepackage{proof}
\usepackage{supertabular}
\usepackage{tikz-cd}
\usepackage{unicode-math}
\usepackage{xltxtra}
\usepackage{xunicode}

\usepackage{setspace,url,hyperref}

\definecolor{dark-gray}{gray}{0.20}

% fonts
% \setromanfont[Mapping=tex-text, Ligatures=Rare, Numbers=OldStyle]{Linux Libertine O}
\setmathfont{Asana-Math.otf}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}

\def\IModeColorName{MidnightBlue}
\def\OModeColorName{Maroon}
\newcommand\IMode[1]{{\color{\IModeColorName}{#1}}}
\newcommand\OMode[1]{{\color{\OModeColorName}{#1}}}
\newcommand\Quote[1]{{\color{Gray}{«}}#1{\color{Gray}{»}}}

\newcommand\HypJ[2]{#1\ \ (#2)}
\newcommand\GenJ[2]{\vert_{\IMode{#1}}\; #2}
\newcommand\JJ{J}
\newcommand\RSet{\mathfrak{R}}
\newcommand\JSet{\mathfrak{J}}

\newcommand\IsTac[1]{\IMode{#1}\ \textit{tactic}}

\newcommand\MkSet[1]{\left\{#1\right\}}
\newcommand\MkFam[3]{\MkSet{#1_{#2}}_{#2\in #3}}
\newcommand\Member[2]{\IMode{#1}\in\IMode{#2}}
\newcommand\EqMember[3]{\IMode{#1}=\IMode{#2}\in\IMode{#3}}

\newcommand\MkValence[3]{\left\{#1\right\}\left[#2\right].\, #3}
\newcommand\MkBTm[3]{\left\{#1\right\}\left[#2\right].\, #3}
\newcommand\MkArity[2]{\left(#1\right) #2}
\newcommand\IsArity[1]{\IMode{#1}\ \textit{arity}}
\newcommand\IsValence[1]{\IMode{#1}\ \textit{valence}}
\newcommand\IsSort[1]{\IMode{#1}\ \textit{sort}}
\newcommand\Leq[2]{\IMode{#1}\leq\IMode{#2}}

\newcommand\Symbols{\mathbb{I}}
\newcommand\Finsets{\mathbb{F}}
\newcommand\Sorts{\mathcal{S}}
\newcommand\Valences{\mathcal{V}}
\newcommand\Arities{\mathcal{A}}
\newcommand\Operators{\mathcal{O}}

\newcommand\ParamsOf{\pi_\mathfrak{p}}
\newcommand\ArityOf{\pi_\mathfrak{a}}
\newcommand\Cats{\mathbf{Cat}}
\newcommand\Discrete[1]{#1_{\equiv}}
\newcommand\Sets{\mathbf{Set}}
\newcommand\SCtx{\mathbf{SCtx}}

\newcommand\IsOperator[3]{\IMode{#1}\Vdash \IMode{#2} : \OMode{#3}}

\newcommand\IsMetaCtx[1]{\IMode{#1}\ \textit{mctx}}
\newcommand\IsVarCtx[1]{\IMode{#1}\ \textit{vctx}}
\newcommand\IsSymCtx[1]{\IMode{#1}\ \textit{sctx}}

\newcommand\Lookup[3]{\IMode{#1}\ni\IMode{#2}:\OMode{#3}}

\newcommand\Grothendieck[2]{\oint^{#1} #2#1}
\newcommand\Pair[2]{\langle #1, #2 \rangle}
\newcommand\Restriction[1]{#1^{*}}
\newcommand\Singleton{\MkSet{\bullet}}

\newcommand\Comma[2]{#1 \downarrow #2}

\newcommand\IsAbt[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}:\OMode{#5}%
}

\newcommand\IsBTm[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}:\IMode{#5}%
}

\newcommand\MV[1]{\textsc{#1}}
\newcommand\MApp[3]{#1\left\{#2\right\}\left(#3\right)}
\newcommand\App[2]{#1\left(#2\right)}
\newcommand\Dom[1]{\left\vert #1\right\vert}
\newcommand\FV[1]{\mathbf{FV}\left(#1\right)}
\newcommand\FS[1]{\mathbf{FS}\left(#1\right)}
\newcommand\NotIn[2]{\IMode{#1}\notin\IMode{#2}}
\newcommand\SortExp{\mathsf{exp}}

\newcommand\Hom[3]{#1\left[#2,#3\right]}

\newcommand\Subst[3]{
  \left[#1\, /\, #2\right]#3%
}

\newcommand\IsRenaming[3]{
  \IMode{#2}\upharpoonright\IMode{#1}%
  \leadsto\OMode{#3}%
}

\newcommand\IsSubst[4]{%
  \Subst{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}%
  \leadsto\OMode{#4}%
}


\newcommand\IsEq[2]{\IMode{#1} = \IMode{#2}}
\newcommand\IsApart[2]{\IMode{#1} \mathrel{\#} \IMode{#2}}

\newcommand\Define[2]{\IMode{#1}\triangleq\OMode{#2}}


\begin{document}

\title{Abstract Binding Trees}
\date{}
\author{Jon Sterling and Darin Morrison}
\maketitle

\section{Preliminaries}

Fix a set $\Sorts$ of \emph{sorts}. We will say $\IsSort{s}$ when
$\Member{s}{S}$. A valence $\MkValence{\vec{p}}{\vec{q}}{s}$ specifies an
expression of sort $s$ which binds symbols in $\vec{p}$ and variables in
$\vec{q}$.

\[
  \infer{
    \IsValence{\MkValence{p_0,\dots,p_m}{q_0,\dots,q_n}{s}}
  }{
    \IsSort{s} &
    \HypJ{\IsSort{p_i}}{\Leq{i}{m}} &
    \HypJ{\IsSort{q_i}}{\Leq{i}{n}} &
  }
\]

An arity $\MkArity{\vec{v}}{s}$ specifies an operator of sort $s$ with
arguments of valences $\vec{v}$. We will call the set of valences $\Valences$,
and the set of arities $\Arities$.

\[
  \infer{
    \IsArity{\MkArity{v_0,...,v_n}{s}}
  }{
    \IsSort{s} &
    \HypJ{\IsValence{v_i}}{\Leq{i}{n}}
  }
\]


Let $\Symbols$ be an infinite set of symbols. Let $\Finsets$ be the category of
finite subsets of $\Symbols$ and their injective maps; then the comma
construction $\Define{\SCtx}{\Comma{\Finsets}{\Discrete{\Sorts}}}$, with
$\Discrete{\Sorts}$ the discrete category on the set $\mathcal{S}$, is the
category of contexts of symbols, whose objects are finite sets of symbols $U$
and sort-assignments $\mathfrak{s}:U\to\Sorts$, and whose morphisms are
sort-preserving renamings; we will write $\Upsilon$ for a symbol context
$(U,\mathfrak{s})$.

Then, fix a covariant presheaf (copresheaf) of operators
$\Operators:\SCtx\times\Arities\to\Sets$ such that the arrows in $\SCtx$ lift to
renamings of operators' parameters. Via the Grothendieck
construction\footnote{In this case, $C\Grothendieck{}{\Psi}$ represents the
  category of elements of a copresheaf $\Psi : C\to\Sets$ but we keep the $C$
  implicit and simply refer to it as the Grothendieck construction.
  Alternatively, this construction can be understood as a coend
  $C\Grothendieck{}{\Psi} \cong \int^{c \in C}c / C \otimes
  \Discrete{\Psi(c)}$.} $\Grothendieck{}{(-)} : \Sets^{C}\to\Cats$ on operators
we have a category of objects
$\Member{\Pair{\Pair{\Upsilon}{\varrho}}{\vartheta}}{\Grothendieck{}{\Operators}}$
for $\Member{\vartheta}{\Operators\Pair{\Upsilon}{\varrho}}$ and morphisms
$\Hom{\Grothendieck{}{\Operators}}{\Pair{\Pair{\Upsilon}{\varrho}}{\vartheta}}{\Pair{\Pair{\Upsilon'}{\varrho'}}{\vartheta'}}$
for $f : \Pair{\Upsilon}{\varrho}\to\Pair{\Upsilon'}{\varrho'}$ such that
$\EqMember{\Restriction{f}\vartheta}{\vartheta'}{\Operators\Pair{\Upsilon'}{\varrho'}}$.
Equivalently, $\Grothendieck{}{\Operators}$ is the pullback of $\Operators$
along the universal $\Sets$-bundle where $\pi_{\Operators}$ is a discrete
Grothendieck opfibration and $ap_{\Singleton}$ is the forgetful functor from pointed sets:

\[
\begin{tikzcd}[ampersand replacement = \&, sep = large]
  {\Grothendieck{}{\Operators}}
    \arrow[r, "{\pi_{!}}"]
    \arrow[d, "{\pi_{\Operators}}" left]
  \& {\Singleton / \Sets}
    \arrow[d, "{ap_{\Singleton}}"] \\
  {\SCtx\times\Arities}
     \arrow[r, "{\Operators}" below]
  \& {\Sets} \\
\end{tikzcd}
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\vartheta}{\varrho}
  }{
    \Member{\vartheta}{\Operators\langle\Upsilon,\varrho\rangle}
  }
\]

The judgment $\IsOperator{\Upsilon}{\vartheta}{\varrho}$ enjoys the structural
properties of weakening and exchange via the functoriality of
$\Operators$.

\paragraph{Examples}

Operators are defined by specifying the fibers of $\pi_{\Operators}$ in which
they reside. For instance, consider the lambda calculus with a single sort,
$\SortExp$; we give its signature by asserting the following about its
operators:
\begin{gather*}
  \IsOperator{\Upsilon}{\lambda}{
    \MkArity{\MkValence{\cdot}{\SortExp}{\SortExp}}{\SortExp}
  }\\
  \IsOperator{\Upsilon}{\mathsf{ap}}{
    \MkArity{
      \MkValence{\cdot}{\cdot}{\SortExp},
      \MkValence{\cdot}{\cdot}{\SortExp}
    }{\SortExp}
  }
\end{gather*}

So far, we have made no use of symbols and parameters; however, consider the
extension of the calculus with assignables (references):

\begin{gather*}
  \IsOperator{\Upsilon}{\mathsf{decl}}{
    \MkArity{
      \MkValence{\cdot}{\cdot}{\SortExp},
      \MkValence{\SortExp}{\cdot}{\SortExp}
    }{
      \SortExp
    }
  }\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathsf{get}[u]}{
    \MkArity{
      \cdot
    }{
      \SortExp
    }
  }\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathsf{set}[u]}{
    \MkArity{
      \MkValence{\cdot}{\cdot}{\SortExp}
    }{
      \SortExp
    }
  }
\end{gather*}

Declaring a new assignable consists in providing an initial value, and an
expression with a free symbol (which shall represent the assignable in scope).
Weakening can be seen as inducing a ``degeneracy map'' on operators, whereas a
renaming $u\mapsto v$ will take $\mathsf{get}[u]$ to $\mathsf{get}[v]$.

\section{Contexts}

In general, we will have three kinds of context: metavariable contexts,
variable contexts, and symbol (parameter) contexts. A metavariable context
$\Omega$ consists of bindings of valences to metavariables; a variable context
$\Gamma$ is a collection of bindings of sorts to variables, and a parameter
context $\Upsilon$ is a collection of bindings of sorts to symbols.

\begin{gather*}
  \infer{
    \IsMetaCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsMetaCtx{\Omega,\MV{m}:v}
  }{
    \IsMetaCtx{\Omega} &
    \IsValence{v} &
    \NotIn{\MV{m}}{\Dom\Omega}
  }
\end{gather*}

\begin{gather*}
  \infer{
    \IsVarCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsVarCtx{\Gamma,x:s}
  }{
    \IsVarCtx{\Gamma} &
    \IsSort{s} &
    \NotIn{x}{\Dom\Gamma}
  }
\end{gather*}

\begin{gather*}
  \infer{
    \IsSymCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsSymCtx{\Upsilon,u:s}
  }{
    \IsVarCtx{\Upsilon} &
    \IsSort{s} &
    \NotIn{u}{\Dom\Upsilon}
  }
\end{gather*}

\section{Abstract Binding Trees}

Let the judgment $\IsAbt{\Omega}{\Upsilon}{\Gamma}{M}{s}$ presuppose
$\IsMetaCtx{\Omega}$, $\IsSymCtx\Upsilon$, $\IsVarCtx\Gamma$ and $\IsSort{s}$,
meaning that $M$ is an abstract binding tree of sort $s$, with metavariables in
$\Omega$, parameters in $\Upsilon$, and variables in $\Gamma$. Let the judgment
$\IsBTm{\Omega}{\Upsilon}{\Gamma}{E}{v}$ presuppose $\IsValence{v}$.  Then, the
syntax of abstract binding trees is inductively defined in four rules:

\begin{gather*}
  \infer[\textit{var}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{x}{s}
  }{
    \Lookup{\Gamma}{x}{s}
  }\\[6pt]
  %
  \infer[\textit{mvar}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{
      \MApp{\MV{m}}{u_0,\dots,u_m}{M_0,\dots,M_n}
    }{s}
  }{
    \begin{array}{l}
      \Lookup{\Omega}{\MV{m}}{\MkValence{p_0,\dots,p_m}{q_0,\dots,q_n}{s}}\\
      \HypJ{\Lookup{\Upsilon}{u_i}{p_i}}{\Leq{i}{m}}\\
      \HypJ{
        \IsAbt{\Omega}{\Upsilon}{\Gamma}{M_i}{q_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }\\[6pt]
  %
  \infer[\textit{app}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{s}
  }{
    \begin{array}{l}
      \IsOperator{\Upsilon}{\vartheta}{
        v_1,\dots,v_n
      }\\
      \HypJ{
        \IsBTm{\Omega}{\Upsilon}{\Gamma}{E_i}{q_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }\\[6pt]
  \infer[\textit{abs}]{
    \IsBTm{\Omega}{\Upsilon}{\Gamma}{
      \left(\MkBTm{\vec{u}}{\vec{x}}{M}\right)
    }{
      \left(\MkValence{\vec{p}}{\vec{q}}{s}\right)
    }
  }{
    \IsAbt{\Omega}{\Upsilon, \vec{u}:\vec{p}}{\Gamma,\vec{x}:{\vec{q}}}{
      M
    }{
      s
    }
  }
\end{gather*}

Abstract binding trees are identified up to $\alpha$-equivalence.

\subsection{Substitution of Variables}

Variable substitution in abstract binding trees is defined inductively by a
pair of judgments, $\IsSubst{N}{x}{M}{M'}$ and $\IsSubst{N}{x}{E}{E'}$:

\begin{gather*}
  \infer{
    \IsSubst{N}{x}{y}{N}
  }{
    \IsEq{x}{y}
  }\qquad
  \infer{
    \IsSubst{N}{x}{y}{y}
  }{
    \IsApart{x}{y}
  }\\[6pt]
  \infer{
    \IsSubst{N}{x}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{u}}{M'_0,\dots,M'_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{M_i}{M'_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsSubst{N}{x}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta}{E'_0,\dots,E'_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{E_i}{E'_i}
    }{
      \Leq{i}{n}
    }
  }
\end{gather*}
\begin{gather*}
  \infer{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M'}
    }
  }{
    \NotIn{x}{\vec{y}} &
    \IsApart{\vec{y}}{\FV{N}} &
    \IsSubst{N}{x}{M}{M'}
  }\qquad
  \infer{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }
  }{
    \Member{x}{\vec{y}} &
    \IsApart{\vec{y}}{\FV{N}}
  }
\end{gather*}

Because terms are identified up to $\alpha$-equivalence, the variable
substitution judgment is functional in its inputs, and so we are justified in
writing $\Subst{N}{x}{M}$ for $M'$ when $\IsSubst{N}{x}{M}{M'}$. We write
$\Subst{\vec{N}}{\vec{x}}{M}$ for the simultaneous substitution of $\vec{N}$
for $\vec{x}$ in $M$.

\subsection{Substitution of Metavariables}

Metavariable substitution is defined inductively by the judgment
$\IsSubst{E}{\MV{m}}{M}{M'}$:

\begin{gather*}
  \infer{
    \IsSubst{E}{\MV{m}}{x}{x}
  }{
  }\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \MApp{\MV{n}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{n}}{\vec{u}}{M'_0,\dots,M'_n}
    }
  }{
    \IsApart{\MV{m}}{\MV{n}} &
    \HypJ{
      \IsSubst{E}{\MV{n}}{M_i}{M'_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  %%% \infer{
  %%%   \IsSubst{
  %%%     \MkBTm{\vec{u}}{x_0,\dots,x_n}{N}
  %%%   }{\MV{m}}{
  %%%     \MApp{\MV{n}}{\vec{v}}{M_0,\dots,M_n}
  %%%   }{
  %%%     %TODO!!!
  %%%     %\Rename{\vec{v}}{\vec{u}}{
  %%%     \Subst{\vec{M}}{\vec{x}}{N}
  %%%     % }
  %%%   }
  %%% }{
  %%%   \IsEq{\MV{m}}{\MV{n}}
  %%% }\\[6pt]
  %%% \infer{
  %%%   \IsSubst{E}{\MV{m}}{
  %%%     \App{\vartheta}{F_0,\dots,F_n}
  %%%   }{
  %%%   }
  %%% }{
  %%% }
\end{gather*}

\end{document}
