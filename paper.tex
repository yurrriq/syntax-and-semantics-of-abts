\documentclass[11pt]{article}

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{amsmath, amsthm, stmaryrd, scalerel, amssymb}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{geometry}
\usepackage{ifthen}
\usepackage{proof}
\usepackage{supertabular}
\usepackage{tikz-cd}
\usepackage{unicode-math}
\usepackage{xltxtra}
\usepackage{xunicode}

\usepackage{setspace,url,hyperref}

\definecolor{dark-gray}{gray}{0.20}

% fonts
% \setromanfont[Mapping=tex-text, Ligatures=Rare, Numbers=OldStyle]{Linux Libertine O}
\setmathfont{Asana-Math.otf}

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}
\numberwithin{equation}{section}

\def\IModeColorName{MidnightBlue}
\def\OModeColorName{Maroon}

\newcommand\IMode[1]{{\color{\IModeColorName}{#1}}}
\newcommand\OMode[1]{{\color{\OModeColorName}{#1}}}

\newcommand\HypJ[2]{#1\ \ (#2)}
\newcommand\GenJ[2]{\vert_{\IMode{#1}}\; #2}

\newcommand\IsTac[1]{\IMode{#1}\ \textit{tactic}}

\newcommand\MkSet[1]{\left\{#1\right\}}
\newcommand\Member[2]{\IMode{#1}\in\IMode{#2}}
\newcommand\EqMember[3]{\IMode{#1}=\IMode{#2}\in\IMode{#3}}
\newcommand\Of[2]{\IMode{#1} : \IMode{#2}}

\newcommand\MkValence[3]{\{#1\}[#2].\, #3}
\newcommand\MkBTm[3]{\{#1\}[#2].\, #3}
\newcommand\MkArity[2]{(#1) #2}
\newcommand\IsArity[1]{\IMode{#1}\ \textit{arity}}
\newcommand\IsValence[1]{\IMode{#1}\ \textit{valence}}
\newcommand\IsSort[1]{\IMode{#1}\ \textit{sort}}
\newcommand\Leq[2]{\IMode{#1}\leq\IMode{#2}}

\newcommand\ArrId[1]{1_{#1}}
\newcommand\Match[2]{\IMode{#1}\equiv\OMode{#2}}

\newcommand\Symbols{\mathbb{I}}
\newcommand\Finsets{\mathbb{F}}
\newcommand\Sorts{\mathcal{S}}
\newcommand\Valences{\mathcal{V}}
\newcommand\Arities{\mathcal{A}}
\newcommand\Operators{\mathcal{O}}

\newcommand\Cats{\mathbf{Cat}}
\newcommand\Discrete[1]{#1_{\equiv}}
\newcommand\Sets{\mathbf{Set}}
\newcommand\SCtx{\mathbf{SCtx}}

\newcommand\IsOperator[3]{\IMode{#1}\Vdash \IMode{#2} : \OMode{#3}}

\newcommand\IsMetaCtx[1]{\IMode{#1}\ \textit{mctx}}
\newcommand\IsVarCtx[1]{\IMode{#1}\ \textit{vctx}}
\newcommand\IsSymCtx[1]{\IMode{#1}\ \textit{sctx}}

\newcommand\Lookup[3]{\IMode{#1}\ni\IMode{#2}:\OMode{#3}}

\newcommand\Grothendieck[2]{\oint^{#1} #2#1}
\newcommand\Pair[2]{\langle #1, #2 \rangle}
\newcommand\Lift[2]{
  \Operators\langle#1\ifthenelse{\equal{#2}{}}{}{, #2}\rangle
}
\newcommand\PairTimes[2]{\langle #1\, {\scriptstyle {{\times}}}\, #2 \rangle}
\newcommand\Singleton{\bullet}
\newcommand\Forget[1]{|\, #1\, |}

\newcommand\Comma[2]{#1 \downarrow #2}
\newcommand\Coslice[2]{#1\, /\, #2}

\newcommand\IsAbt[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}:\OMode{#5}%
}

\newcommand\IsBTm[5]{%
  \IMode{#1}\triangleright%
  \IMode{#2}\parallel%
  \IMode{#3}\vdash%
  \IMode{#4}:\IMode{#5}%
}

\newcommand\MV[1]{\textsc{#1}}
\newcommand\MApp[3]{#1\{#2\}(#3)}
\newcommand\App[2]{#1(#2)}
\newcommand\Dom[1]{\left\vert #1\right\vert}
\newcommand\FV[1]{\mathbf{FV}\left(#1\right)}
\newcommand\FS[1]{\mathbf{FS}\left(#1\right)}
\newcommand\NotIn[2]{\IMode{#1}\notin\IMode{#2}}
\newcommand\SortExp{\mathsf{exp}}

\newcommand\Hom[3]{#1\left[#2,#3\right]}

\newcommand\Rename[2]{
  #2\upharpoonright #1
}
\newcommand\IsRenaming[3]{
  \Rename{\IMode{#1}}{\IMode{#2}}%
  \leadsto\OMode{#3}%
}

\newcommand\Subst[3]{
  \left[#1\, /\, #2\right]#3%
}

\newcommand\IsSubst[4]{%
  \Subst{\IMode{#1}}{\IMode{#2}}{\IMode{#3}}%
  \leadsto\OMode{#4}%
}


\newcommand\IsEq[2]{\IMode{#1} = \IMode{#2}}
\newcommand\IsApart[2]{\IMode{#1} \mathrel{\#} \IMode{#2}}

\newcommand\Define[2]{\IMode{#1}\triangleq\OMode{#2}}


\begin{document}

\title{Abstract Binding Trees}
\date{}
\author{Jon Sterling and Darin Morrison}
\maketitle

\section{Preliminaries}

Fix a set $\Sorts$ of \emph{sorts}. We will say $\IsSort{s}$ when
$\Member{s}{S}$. A valence $\MkValence{\vec{p}}{\vec{q}}{s}$ specifies an
expression of sort $s$ which binds symbols in $\vec{p}$ and variables in
$\vec{q}$.

\[
  \infer{
    \IsValence{\MkValence{p_0,\dots,p_m}{q_0,\dots,q_n}{s}}
  }{
    \IsSort{s} &
    \HypJ{\IsSort{p_i}}{\Leq{i}{m}} &
    \HypJ{\IsSort{q_i}}{\Leq{i}{n}} &
  }
\]

An arity $\MkArity{\vec{v}}{s}$ specifies an operator of sort $s$ with
arguments of valences $\vec{v}$. We will call the set of valences $\Valences$,
and the set of arities $\Arities$.

\[
  \infer{
    \IsArity{\MkArity{v_0,...,v_n}{s}}
  }{
    \IsSort{s} &
    \HypJ{\IsValence{v_i}}{\Leq{i}{n}}
  }
\]


Let $\Symbols$ be an infinite set of symbols. Let $\Finsets$ be the category of
finite subsets of $\Symbols$ and their injective maps; then the comma
construction $\Define{\SCtx}{\Comma{\Finsets}{\Discrete{\Sorts}}}$, with
$\Discrete{\Sorts}$ the discrete category on the set $\mathcal{S}$, is the
category of contexts of symbols, whose objects are finite sets of symbols $U$
and sort-assignments $\Of{\mathfrak{s}}{U\to\Sorts}$, and whose morphisms are
sort-preserving renamings; we will write $\Upsilon$ for a symbol context
$(U,\mathfrak{s})$.

Then, fix a covariant presheaf (copresheaf) of operators
$\Of{\Operators}{\SCtx\times\Discrete{\Arities}\to\Sets}$ such that the arrows
in $\SCtx$ lift to renamings of operators' parameters. Via the Grothendieck
construction\footnote{In this case, $C\Grothendieck{}{\Psi}$ represents the
  category of elements of a copresheaf $\Of{\Psi}{C\to\Sets}$ but we keep the
  $C$ implicit and simply refer to it as the Grothendieck construction.
  Alternatively, this construction can be understood as a coend
$\IMode{C\Grothendieck{}{\Psi}}\cong \IMode{\int^{c \in C}\Coslice{c}{C}
\otimes \Discrete{\Psi(c)}}$.} $\Of{\Grothendieck{}{(-)}}{\Sets^{C}\to\Cats}$
on operators, we have a category of objects
$\Member{\Pair{\Pair{\Upsilon}{a}}{\vartheta}}{\Grothendieck{}{\Operators}}$
for $\Member{\vartheta}{\Operators\Pair{\Upsilon}{a}}$ and morphisms
$\Hom{\Grothendieck{}{\Operators}}{\Pair{\Pair{\Upsilon}{a}}{\vartheta}}{\Pair{\Pair{\Upsilon'}{a'}}{\vartheta'}}$
for $\Of{f}{\Pair{\Upsilon}{a}\to\Pair{\Upsilon'}{a'}}$ such that
$\EqMember{\Lift{f}{}(\vartheta)}{\vartheta'}{\Operators\Pair{\Upsilon'}{a'}}$.
Equivalently, $\Grothendieck{}{\Operators}$ is the pullback of $\Operators$
along the universal $\Sets$-bundle where $\pi_{\Operators}$ is a discrete
Grothendieck opfibration and $\Forget{-}_{\Singleton}$ is the forgetful functor
from pointed sets:

\[
\begin{tikzcd}[ampersand replacement = \&, sep = large]
  {\Grothendieck{}{\Operators}}
    \arrow[r, "{\pi_{\in}}"]
    \arrow[d, "{\pi_{\Operators}}" left]
  \& {\Sets_{\Singleton}}
    \arrow[d, "{\Forget{-}_{\Singleton}}"] \\
  {\SCtx\times\Discrete{\Arities}}
     \arrow[r, "{\Operators}" below]
  \& {\Sets} \\
\end{tikzcd}
\]

\[
  \infer{
    \IsOperator{\Upsilon}{\vartheta}{a}
  }{
    \Member{\vartheta}{\Operators\langle\Upsilon,a\rangle}
  }
\]

The judgment $\IsOperator{\Upsilon}{\vartheta}{a}$ enjoys the structural
properties of weakening and exchange via the functoriality of
$\Operators$.

\paragraph{Examples}

Operators are defined by specifying the fibers of $\pi_{\Operators}$ in which
they reside. For instance, consider the lambda calculus with a single sort,
$\SortExp$; we give its signature by asserting the following about its
operators:
\begin{gather*}
  \IsOperator{\Upsilon}{\lambda}{
    \MkArity{\MkValence{\cdot}{\SortExp}{\SortExp}}{\SortExp}
  }\\
  \IsOperator{\Upsilon}{\mathsf{ap}}{
    \MkArity{
      \MkValence{\cdot}{\cdot}{\SortExp},
      \MkValence{\cdot}{\cdot}{\SortExp}
    }{\SortExp}
  }
\end{gather*}

So far, we have made no use of symbols and parameters; however, consider the
extension of the calculus with assignables (references):

\begin{gather*}
  \IsOperator{\Upsilon}{\mathsf{decl}}{
    \MkArity{
      \MkValence{\cdot}{\cdot}{\SortExp},
      \MkValence{\SortExp}{\cdot}{\SortExp}
    }{
      \SortExp
    }
  }\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathsf{get}[u]}{
    \MkArity{
      \cdot
    }{
      \SortExp
    }
  }\\
  \IsOperator{\Upsilon,u:\SortExp}{\mathsf{set}[u]}{
    \MkArity{
      \MkValence{\cdot}{\cdot}{\SortExp}
    }{
      \SortExp
    }
  }
\end{gather*}

Declaring a new assignable consists in providing an initial value, and an
expression binding a symbol (which shall represent the assignable in scope).
Note that the functoriality of $\Operators$ guarantees for any renaming
$\Of{\varrho}{\Upsilon\to\Upsilon'}$ and $\Of{f}{a\to a'}$, a lifted map
$\Lift{\varrho}{f}$ such that
$\IsOperator{\Upsilon'}{\Lift{\varrho}{f}(\vartheta)}{a}$ when
$\IsOperator{\Upsilon}{\vartheta}{a'}$. Because the category
$\Discrete{\Arities}$ is discrete and has only identity arrows, through an abuse
of notation we will often write $\Lift{\varrho}{}$ to mean
$\Lift{\varrho}{\ArrId{}}$. In particular, the renaming
$\Upsilon,u\mapsto\Upsilon,v$ shall take $\mathsf{get}[u]$ to $\mathsf{get}[v]$.

\section{Contexts}

In general, we will have three kinds of context: metavariable contexts,
variable contexts, and symbol (parameter) contexts. A metavariable context
$\Omega$ consists of bindings of valences to metavariables; a variable context
$\Gamma$ is a collection of bindings of sorts to variables, and a parameter
context $\Upsilon$ is a collection of bindings of sorts to symbols.

\begin{gather*}
  \infer{
    \IsMetaCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsMetaCtx{\Omega,\MV{m}:v}
  }{
    \IsMetaCtx{\Omega} &
    \IsValence{v} &
    \NotIn{\MV{m}}{\Dom\Omega}
  }
\end{gather*}

\begin{gather*}
  \infer{
    \IsVarCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsVarCtx{\Gamma,x:s}
  }{
    \IsVarCtx{\Gamma} &
    \IsSort{s} &
    \NotIn{x}{\Dom\Gamma}
  }
\end{gather*}

\begin{gather*}
  \infer{
    \IsSymCtx{\cdot}
  }{
  }\qquad
  \infer{
    \IsSymCtx{\Upsilon,u:s}
  }{
    \IsVarCtx{\Upsilon} &
    \IsSort{s} &
    \NotIn{u}{\Dom\Upsilon}
  }
\end{gather*}

\section{Abstract Binding Trees}

Let the judgment $\IsAbt{\Omega}{\Upsilon}{\Gamma}{M}{s}$ presuppose
$\IsMetaCtx{\Omega}$, $\IsSymCtx\Upsilon$, $\IsVarCtx\Gamma$ and $\IsSort{s}$,
meaning that $M$ is an abstract binding tree of sort $s$, with metavariables in
$\Omega$, parameters in $\Upsilon$, and variables in $\Gamma$. Let the judgment
$\IsBTm{\Omega}{\Upsilon}{\Gamma}{E}{v}$ presuppose $\IsValence{v}$.  Then, the
syntax of abstract binding trees is inductively defined in four rules:

\begin{gather*}
  \infer[\textit{var}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{x}{s}
  }{
    \Lookup{\Gamma}{x}{s}
  }\\[6pt]
  %
  \infer[\textit{mvar}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{
      \MApp{\MV{m}}{u_0,\dots,u_m}{M_0,\dots,M_n}
    }{s}
  }{
    \begin{array}{l}
      \Lookup{\Omega}{\MV{m}}{\MkValence{p_0,\dots,p_m}{q_0,\dots,q_n}{s}}\\
      \HypJ{\Lookup{\Upsilon}{u_i}{p_i}}{\Leq{i}{m}}\\
      \HypJ{
        \IsAbt{\Omega}{\Upsilon}{\Gamma}{M_i}{q_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }\\[6pt]
  %
  \infer[\textit{app}]{
    \IsAbt{\Omega}{\Upsilon}{\Gamma}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{s}
  }{
    \begin{array}{l}
      \IsOperator{\Upsilon}{\vartheta}{
        v_1,\dots,v_n
      }\\
      \HypJ{
        \IsBTm{\Omega}{\Upsilon}{\Gamma}{E_i}{q_i}
      }{
        \Leq{i}{n}
      }
    \end{array}
  }\\[6pt]
  \infer[\textit{abs}]{
    \IsBTm{\Omega}{\Upsilon}{\Gamma}{
      \left(\MkBTm{\vec{u}}{\vec{x}}{M}\right)
    }{
      \left(\MkValence{\vec{p}}{\vec{q}}{s}\right)
    }
  }{
    \IsAbt{\Omega}{\Upsilon, \vec{u}:\vec{p}}{\Gamma,\vec{x}:{\vec{q}}}{
      M
    }{
      s
    }
  }
\end{gather*}

Abstract binding trees are identified up to $\alpha$-equivalence. Let $\FS{M}$
be the collection of symbols free in $M$, and let $\FV{M}$ be the collection of
variables free $\pi_\Operators$ to operators in $M$. %% TODO: actually define these

\subsection{Renaming of Symbols}

The only place that symbols appear in our calculus is as parameters to
operators (unlike variables, symbols are not terms). Therefore, the functorial
action of the operator presheaf can be lifted into terms by recursion on their
structure, via a pair of judgments $\IsRenaming{\varrho}{M}{N}$ and
$\IsRenaming{\varrho}{E}{F}$, presupposing
$\Of{\varrho}{\Upsilon\to\Upsilon'}$, and $\IsAbt{\Omega}{\Upsilon}{\Gamma}{M}{s}$
and $\IsAbt{\Omega}{\Upsilon}{\Gamma}{E}{v}$ respectively:

\begin{gather*}
  \infer{
    \IsRenaming{\varrho}{x}{x}
  }{
  }\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{v}}{N_0,\dots,N_n}
    }
  }{
    \Match{\varrho(\vec{u})}{\vec{v}} &
    \HypJ{
      \IsRenaming{\varrho}{M_i}{N_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta'}{F_0,\dots,F_n}
    }
  }{
    \Match{\Lift{\varrho}{}(\vartheta)}{\vartheta'} &
    \HypJ{
      \IsRenaming{\varrho}{E_i}{F_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsRenaming{\varrho}{
      \left(\MkBTm{\vec{u}}{\vec{x}}{M}\right)
    }{
      \left(\MkBTm{\vec{u}}{\vec{x}}{N}\right)
    }
  }{
    \IsRenaming{\varrho\setminus\vec{u}}{M}{N}
  }
\end{gather*}

Above, the notation $\varrho\setminus\vec{u}$ means the omission of the
variables $\vec{u}$ from the renaming $\varrho$. Because terms are identified
up to $\alpha$-equivalence, the renaming judgment is functional in its input,
and so we are justified in writing $\Rename{\varrho}{M}$ for $N$ when
$\IsRenaming{\varrho}{M}{N}$.

%%% TODO: show that renaming preserves wellformedness

\subsection{Substitution of Variables}

Variable substitution in abstract binding trees is defined inductively by a
pair of judgments, $\IsSubst{N}{x}{M}{M'}$ and $\IsSubst{N}{x}{E}{F}$:

\begin{gather*}
  \infer{
    \IsSubst{N}{x}{y}{N}
  }{
    \IsEq{x}{y}
  }\qquad
  \infer{
    \IsSubst{N}{x}{y}{y}
  }{
    \IsApart{x}{y}
  }\\[6pt]
  \infer{
    \IsSubst{N}{x}{
      \MApp{\MV{m}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{m}}{\vec{u}}{M'_0,\dots,M'_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{M_i}{M'_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsSubst{N}{x}{
      \App{\vartheta}{E_0,\dots,E_n}
    }{
      \App{\vartheta}{F_0,\dots,F_n}
    }
  }{
    \HypJ{
      \IsSubst{N}{x}{E_i}{F_i}
    }{
      \Leq{i}{n}
    }
  }
\end{gather*}
\begin{gather*}
  \infer{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M'}
    }
  }{
    \NotIn{x}{\vec{y}} &
    \IsApart{\vec{u}}{\FS{N}} &
    \IsApart{\vec{y}}{\FV{N}} &
    \IsSubst{N}{x}{M}{M'}
  }\qquad
  \infer{
    \IsSubst{N}{x}{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{y}}{M}
    }
  }{
    \Member{x}{\vec{y}} &
    \IsApart{\vec{u}}{\FS{N}} &
    \IsApart{\vec{y}}{\FV{N}}
  }
\end{gather*}

Going forward, we will write $\Subst{N}{x}{M}$ for $M'$ when
$\IsSubst{N}{x}{M}{M'}$, and $\Subst{\vec{N}}{\vec{x}}{M}$ for the
simultaneous substitution of $\vec{N}$ for $\vec{x}$ in $M$.

\subsection{Substitution of Metavariables}

Metavariables are substituted by bound terms; since a metavariable may only
appear in an application expression $\MApp{\MV{m}}{\cdots}{\cdots}$, we will
instantiate the bound term at the supplied parameters and arguments.
Substitution for metavariables is defined inductively by the judgments
$\IsSubst{E}{\MV{m}}{M}{N}$ and $\IsSubst{E}{\MV{m}}{F}{F'}$:

\begin{gather*}
  \infer{
    \IsSubst{E}{\MV{m}}{x}{x}
  }{
  }\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \MApp{\MV{n}}{\vec{u}}{M_0,\dots,M_n}
    }{
      \MApp{\MV{n}}{\vec{u}}{N_0,\dots,N_n}
    }
  }{
    \IsApart{\MV{m}}{\MV{n}} &
    \HypJ{
      \IsSubst{E}{\MV{n}}{M_i}{N_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsSubst{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }{\MV{m}}{
      \MApp{\MV{n}}{\vec{v}}{\vec{M}}
    }{
      N''
    }
  }{
    \IsEq{\MV{m}}{\MV{n}} &
    \IsSubst{\vec{M}}{\vec{x}}{N}{N'} &
    \IsRenaming{\MkSet{\vec{u}\mapsto\vec{v}}}{N'}{N''}
  }\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \App{\vartheta}{F_0,\dots,F_n}
    }{
      \App{\vartheta}{F'_0,\dots,F'_n}
    }
  }{
    \HypJ{
      \IsSubst{E}{\MV{m}}{F_i}{F'_i}
    }{
      \Leq{i}{n}
    }
  }\\[6pt]
  \infer{
    \IsSubst{E}{\MV{m}}{
      \MkBTm{\vec{u}}{\vec{x}}{M}
    }{
      \MkBTm{\vec{u}}{\vec{x}}{N}
    }
  }{
    \IsApart{\vec{u}}{\FS{E}} &
    \IsApart{\vec{x}}{\FV{E}} &
    \IsSubst{E}{\MV{m}}{M}{N}
  }
\end{gather*}

As usual, we will write $\Subst{E}{\MV{m}}{M}$ for $N$ when
$\IsSubst{E}{\MV{m}}{M}{N}$.

\end{document}
